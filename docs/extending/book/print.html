<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Extending Panopticon</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A deep-dive into extending Panopticon with custom commands and services">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-8b684716.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-f149ad64.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Extending Panopticon</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/your-org/panopticon" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<!--
USER: Please write your introduction here.

Suggested content:
- What does "extending" Panopticon mean?
- Who is this guide for? (library extenders, custom command authors)
- Prerequisites (familiarity with the Prelude Guide)
- How this guide is structured
-->
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="extension-architecture"><a class="header" href="#extension-architecture">Extension Architecture</a></h1>
<p>Before implementing your first custom command, it helps to understand the mental model behind Panopticon’s extension system. This chapter provides the foundational understanding you need to work effectively with the framework.</p>
<h2 id="the-big-picture"><a class="header" href="#the-big-picture">The Big Picture</a></h2>
<p>Panopticon separates <strong>what a command is</strong> from <strong>how it runs</strong>. This separation enables:</p>
<ul>
<li><strong>Compile-time validation</strong> of command specifications before any code executes</li>
<li><strong>Type safety</strong> for attribute parsing and result declarations</li>
<li><strong>Introspection</strong> of available commands without instantiating them</li>
<li><strong>Dependency analysis</strong> across the pipeline before execution begins</li>
</ul>
<p>At the heart of this design are three traits that every command must implement:</p>
<pre><code class="language-text">┌─────────────────────────────────────────────────────────────────────────────┐
│                           The Three-Trait Model                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────────┐    ┌─────────────────┐    ┌──────────────┐               │
│   │ Descriptor  │    │ FromAttributes  │    │  Executable  │               │
│   ├─────────────┤    ├─────────────────┤    ├──────────────┤               │
│   │ "What am I?"│    │ "How am I       │    │ "What do I   │               │
│   │             │    │  constructed?"  │    │  actually    │               │
│   │ - type name │    │                 │    │  do?"        │               │
│   │ - attributes│    │ - parse attrs   │    │              │               │
│   │ - results   │    │ - extract deps  │    │ - execute()  │               │
│   └─────────────┘    └─────────────────┘    └──────────────┘               │
│          │                   │                     │                        │
│          └───────────────────┼─────────────────────┘                        │
│                              │                                              │
│                              ▼                                              │
│                    ┌─────────────────┐                                      │
│                    │     Command     │  ← Blanket impl: auto-implemented   │
│                    │   (marker trait)│    for any T: Descriptor +          │
│                    └─────────────────┘    FromAttributes + Executable      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="the-three-traits"><a class="header" href="#the-three-traits">The Three Traits</a></h2>
<h3 id="descriptor-declaring-your-commands-shape"><a class="header" href="#descriptor-declaring-your-commands-shape">Descriptor: Declaring Your Command’s Shape</a></h3>
<p>The <code>Descriptor</code> trait declares static metadata about your command. Think of it as the command’s “schema” - it tells the framework:</p>
<ul>
<li><strong>What type of command is this?</strong> (a unique identifier string)</li>
<li><strong>What attributes does it accept?</strong> (inputs with types, hints, and requirements)</li>
<li><strong>What results does it produce?</strong> (outputs with types and kinds)</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Descriptor: Sized {
    fn command_type() -&gt; &amp;'static str;
    fn command_attributes() -&gt; &amp;'static [AttributeSpec&lt;&amp;'static str&gt;];
    fn command_results() -&gt; &amp;'static [ResultSpec&lt;&amp;'static str&gt;];

    // Default implementations combine your specs with common attributes/results
    fn available_attributes() -&gt; Vec&lt;&amp;'static AttributeSpec&lt;&amp;'static str&gt;&gt;;
    fn available_results() -&gt; Vec&lt;&amp;'static ResultSpec&lt;&amp;'static str&gt;&gt;;
}
<span class="boring">}</span></code></pre>
<p>The framework automatically extends your declared attributes with common ones like <code>when</code> (conditional execution), and extends your results with metadata like <code>status</code> and <code>duration_ms</code>.</p>
<h3 id="fromattributes-parsing-configuration"><a class="header" href="#fromattributes-parsing-configuration">FromAttributes: Parsing Configuration</a></h3>
<p>The <code>FromAttributes</code> trait handles construction from a hashmap of attribute values. It bridges the gap between the raw YAML/JSON configuration and your typed command struct.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FromAttributes: Sized + Descriptor {
    fn from_attributes(attrs: &amp;Attributes) -&gt; Result&lt;Self&gt;;

    // Default: uses Descriptor's spec to scan for template references
    fn extract_dependencies(attrs: &amp;Attributes) -&gt; Result&lt;HashSet&lt;StorePath&gt;&gt;;

    // Default: returns a factory function that validates + constructs
    fn factory() -&gt; CommandFactory;
}
<span class="boring">}</span></code></pre>
<p>The <code>factory()</code> method is particularly important - it produces a <code>CommandFactory</code> that the framework stores and calls at runtime. This factory:</p>
<ol>
<li>Validates the provided attributes against your declared spec</li>
<li>Extracts the <code>when</code> condition (if present) for conditional execution</li>
<li>Calls your <code>from_attributes()</code> to construct the command instance</li>
<li>Wraps the result in an <code>ExecutableWrapper</code> that handles common behavior</li>
</ol>
<h3 id="executable-doing-the-work"><a class="header" href="#executable-doing-the-work">Executable: Doing the Work</a></h3>
<p>The <code>Executable</code> trait is where your command’s actual logic lives. It receives the runtime context and a path where results should be stored.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait Executable: Send + Sync + 'static {
    async fn execute(
        &amp;self,
        context: &amp;ExecutionContext,
        output_prefix: &amp;StorePath
    ) -&gt; Result&lt;()&gt;;
}
<span class="boring">}</span></code></pre>
<p>The <code>ExecutionContext</code> provides:</p>
<ul>
<li>Access to the scalar and tabular stores (read previous results)</li>
<li>Template substitution via Tera</li>
<li>Extension points for custom services</li>
<li>Cancellation checks</li>
</ul>
<h2 id="the-command-trait-automatic-composition"><a class="header" href="#the-command-trait-automatic-composition">The Command Trait: Automatic Composition</a></h2>
<p>You never implement <code>Command</code> directly. Instead, it is automatically implemented for any type that satisfies all three constituent traits:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Command: FromAttributes + Descriptor + Executable {}

// Blanket implementation - you get this for free
impl&lt;T: FromAttributes + Descriptor + Executable&gt; Command for T {}
<span class="boring">}</span></code></pre>
<p>This design means the compiler enforces completeness: you cannot accidentally forget to implement one of the required traits.</p>
<h2 id="commandfactory-and-registration"><a class="header" href="#commandfactory-and-registration">CommandFactory and Registration</a></h2>
<p>When you add a command to a pipeline, Panopticon does not immediately construct your command. Instead, it stores a <code>CommandFactory</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type CommandFactory = Box&lt;dyn Fn(&amp;Attributes) -&gt; Result&lt;Box&lt;dyn Executable&gt;&gt;&gt;;
<span class="boring">}</span></code></pre>
<p>This factory is a closure that captures everything needed to construct your command later, at execution time. The flow looks like this:</p>
<pre><code class="language-text">┌─────────────────────────────────────────────────────────────────────────────┐
│                    Command Registration and Execution                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  COMPILE TIME (Pipeline::add_command)                                       │
│  ─────────────────────────────────────                                      │
│                                                                             │
│  ┌──────────────┐      ┌─────────────────────┐      ┌──────────────────┐   │
│  │ Your Command │ ──▶  │ T::factory()        │ ──▶  │   CommandSpec    │   │
│  │   Type (T)   │      │ (creates closure)   │      │                  │   │
│  └──────────────┘      └─────────────────────┘      │ - namespace_idx  │   │
│        │                                             │ - name           │   │
│        │ T::command_attributes()                     │ - attributes     │   │
│        │ T::command_results()                        │ - factory ◀──────┤   │
│        │ T::extract_dependencies()                   │ - dependencies   │   │
│        ▼                                             │ - expected specs │   │
│  ┌─────────────────────┐                            └──────────────────┘   │
│  │ Static Spec Data    │ ◀───────────────────────────────────┘             │
│  │ (attributes/results)│                                                    │
│  └─────────────────────┘                                                    │
│                                                                             │
│                                                                             │
│  RUNTIME (Pipeline::execute)                                                │
│  ────────────────────────────                                               │
│                                                                             │
│  ┌──────────────────┐      ┌─────────────────────┐     ┌────────────────┐  │
│  │   CommandSpec    │ ──▶  │ factory(&amp;attrs)     │ ──▶ │ Box&lt;dyn        │  │
│  │  .factory(...)   │      │                     │     │   Executable&gt;  │  │
│  └──────────────────┘      │ 1. validate attrs   │     └────────────────┘  │
│                            │ 2. from_attributes()│            │            │
│                            │ 3. wrap in handler  │            ▼            │
│                            └─────────────────────┘     ┌────────────────┐  │
│                                                        │   .execute()   │  │
│                                                        └────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>This deferred construction is essential because:</p>
<ol>
<li><strong>Attributes may contain templates</strong> that reference values not yet computed</li>
<li><strong>Iterative namespaces</strong> create multiple command instances with different <code>item</code> values</li>
<li><strong>Validation happens early</strong>, before any expensive work</li>
</ol>
<h2 id="compile-time-vs-runtime-separation"><a class="header" href="#compile-time-vs-runtime-separation">Compile-Time vs Runtime Separation</a></h2>
<p>A key insight of this architecture is the clean separation between compile-time specification and runtime execution:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Compile Time</th><th>Runtime</th></tr>
</thead>
<tbody>
<tr><td><strong>When</strong></td><td><code>Pipeline::compile()</code></td><td><code>Pipeline::execute()</code></td></tr>
<tr><td><strong>What’s known</strong></td><td>Attribute specs, result specs, dependencies</td><td>Actual attribute values, context state</td></tr>
<tr><td><strong>Type info</strong></td><td>Full generic types (<code>T: Command</code>)</td><td>Type-erased (<code>Box&lt;dyn Executable&gt;</code>)</td></tr>
<tr><td><strong>Validation</strong></td><td>Schema validation, dependency graph, naming</td><td>Value parsing, template resolution</td></tr>
<tr><td><strong>Fails if</strong></td><td>Invalid specs, circular deps, reserved names</td><td>Bad template, missing dependency, execution error</td></tr>
</tbody>
</table>
</div>
<p>This separation provides several benefits:</p>
<h3 id="early-error-detection"><a class="header" href="#early-error-detection">Early Error Detection</a></h3>
<p>Problems with your command specification surface immediately when the pipeline is compiled, not when that particular command happens to run. A typo in an attribute name, a reserved field, or a circular dependency all fail fast.</p>
<h3 id="safe-type-erasure"><a class="header" href="#safe-type-erasure">Safe Type Erasure</a></h3>
<p>At compile time, the framework has access to your full concrete type <code>T</code>. It extracts everything it needs (specs, factory function, dependencies) and stores them in a type-erased <code>CommandSpec</code>. At runtime, only the <code>Box&lt;dyn Executable&gt;</code> interface is needed.</p>
<h3 id="dependency-analysis"><a class="header" href="#dependency-analysis">Dependency Analysis</a></h3>
<p>Before execution begins, the framework can analyze all dependencies between commands. The <code>extract_dependencies()</code> method scans your attributes for store path references, enabling the execution planner to order commands correctly and detect cycles.</p>
<h2 id="why-this-architecture"><a class="header" href="#why-this-architecture">Why This Architecture?</a></h2>
<p>The three-trait model might seem like more ceremony than a simpler “just implement <code>execute()</code>” approach. Here is why the additional structure pays off:</p>
<h3 id="type-safety-for-specs"><a class="header" href="#type-safety-for-specs">Type Safety for Specs</a></h3>
<p>By requiring specs as static data (<code>&amp;'static [AttributeSpec]</code>), the framework ensures your command’s schema is:</p>
<ul>
<li>Known at compile time</li>
<li>Immutable at runtime</li>
<li>Efficiently comparable without heap allocation</li>
</ul>
<p>The <code>CommandSpecBuilder</code> with <code>LazyLock</code> provides a convenient pattern for constructing these specs once on first access.</p>
<h3 id="compile-time-guarantees-for-derived-results"><a class="header" href="#compile-time-guarantees-for-derived-results">Compile-Time Guarantees for Derived Results</a></h3>
<p>Some commands produce dynamic results based on attribute values (e.g., an “export” command where each item in an array becomes a separate output). The <code>LiteralFieldRef</code> mechanism ensures these derived result names can only come from literal (non-template) fields - templates could produce unpredictable names at runtime.</p>
<h3 id="testability"><a class="header" href="#testability">Testability</a></h3>
<p>Each trait can be tested in isolation:</p>
<ul>
<li><code>Descriptor</code>: verify your specs are correct</li>
<li><code>FromAttributes</code>: verify parsing handles edge cases</li>
<li><code>Executable</code>: verify behavior given a mocked context</li>
</ul>
<h3 id="extensibility"><a class="header" href="#extensibility">Extensibility</a></h3>
<p>The trait-based approach enables custom commands without modifying Panopticon’s core. Your types implement the same traits as built-in commands, receiving identical treatment from the framework.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The extension architecture revolves around three traits:</p>
<ul>
<li><strong>Descriptor</strong> declares what your command accepts and produces (static metadata)</li>
<li><strong>FromAttributes</strong> parses configuration into your command struct (construction)</li>
<li><strong>Executable</strong> performs the actual work (runtime behavior)</li>
</ul>
<p>The <strong>Command</strong> marker trait is auto-implemented when you satisfy all three. The <strong>CommandFactory</strong> type enables deferred construction, allowing compile-time validation before runtime execution.</p>
<p>This separation between specification and execution enables early error detection, safe type erasure, and comprehensive dependency analysis - all of which contribute to more reliable pipeline execution.</p>
<hr>
<p>Next: <a href="#your-first-custom-command">Your First Custom Command</a> - Put this knowledge into practice by building a working command from scratch.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="your-first-custom-command"><a class="header" href="#your-first-custom-command">Your First Custom Command</a></h1>
<p>This tutorial walks you through building a complete custom command from scratch. By the end, you will understand how Panopticon’s command system works and be able to create your own commands for any use case.</p>
<h2 id="what-were-building"><a class="header" href="#what-were-building">What We’re Building</a></h2>
<p>We’ll create a <code>ReverseCommand</code> that takes a string input and produces two outputs:</p>
<ol>
<li><strong>reversed</strong> - The input string with its characters reversed</li>
<li><strong>length</strong> - The character count of the original input</li>
</ol>
<p>This simple example covers all the essential concepts:</p>
<ul>
<li>Defining a command schema with attributes and results</li>
<li>Implementing the three required traits (<code>Descriptor</code>, <code>FromAttributes</code>, <code>Executable</code>)</li>
<li>Using Tera template substitution for dynamic inputs</li>
<li>Writing results using <code>InsertBatch</code></li>
<li>Integrating the command into a pipeline</li>
</ul>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before starting, ensure you have:</p>
<ul>
<li>Basic familiarity with Rust (structs, traits, async/await)</li>
<li>A Rust project with <code>panopticon-core</code> as a dependency</li>
<li>Understanding of what commands and pipelines are (see the Guide)</li>
</ul>
<h2 id="command-architecture-overview"><a class="header" href="#command-architecture-overview">Command Architecture Overview</a></h2>
<p>Every Panopticon command consists of three parts:</p>
<pre><code class="language-text">┌─────────────────────────────────────────────────────────────────┐
│                        Custom Command                           │
├─────────────────────────────────────────────────────────────────┤
│  1. Schema (CommandSchema)                                      │
│     - Defines what attributes the command accepts               │
│     - Defines what results the command produces                 │
│     - Validated at initialization time                          │
├─────────────────────────────────────────────────────────────────┤
│  2. Struct + Traits                                             │
│     - Descriptor: Links struct to schema                        │
│     - FromAttributes: Parses attributes into struct fields      │
│     - Executable: Performs the actual work                      │
├─────────────────────────────────────────────────────────────────┤
│  3. Integration                                                 │
│     - Added to namespaces via add_command::&lt;T&gt;()                │
│     - Receives ExecutionContext at runtime                      │
│     - Writes results to the store                               │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="tutorial-structure"><a class="header" href="#tutorial-structure">Tutorial Structure</a></h2>
<p>This tutorial is divided into three sections:</p>
<ol>
<li>
<p><strong><a href="#defining-the-schema">Defining the Schema</a></strong> - Create the command specification using <code>CommandSpecBuilder</code> and <code>AttributeSpecBuilder</code></p>
</li>
<li>
<p><strong><a href="#implementing-traits">Implementing Traits</a></strong> - Implement <code>Descriptor</code>, <code>FromAttributes</code>, and <code>Executable</code> traits</p>
</li>
<li>
<p><strong><a href="#testing-your-command">Testing Your Command</a></strong> - Integrate the command into a pipeline and verify it works</p>
</li>
</ol>
<h2 id="the-complete-example"><a class="header" href="#the-complete-example">The Complete Example</a></h2>
<p>Here’s a preview of what we’ll build. Don’t worry if it looks complex - we’ll explain every line:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::extend::*;
use panopticon_core::prelude::*;

// Step 1: Define the schema
static REVERSE_SPEC: CommandSchema = LazyLock::new(|| {
    CommandSpecBuilder::new()
        .attribute(
            AttributeSpecBuilder::new("input", TypeDef::Scalar(ScalarType::String))
                .required()
                .hint("String to reverse")
                .reference(ReferenceKind::StaticTeraTemplate)
                .build(),
        )
        .fixed_result(
            "reversed",
            TypeDef::Scalar(ScalarType::String),
            Some("The reversed string"),
            ResultKind::Data,
        )
        .fixed_result(
            "length",
            TypeDef::Scalar(ScalarType::Number),
            Some("Character count"),
            ResultKind::Meta,
        )
        .build()
});

// Step 2: Define the struct
pub struct ReverseCommand {
    input: String,
}

// Step 3: Implement Descriptor
impl Descriptor for ReverseCommand {
    fn command_type() -&gt; &amp;'static str { "ReverseCommand" }
    fn command_attributes() -&gt; &amp;'static [AttributeSpec&lt;&amp;'static str&gt;] { &amp;REVERSE_SPEC.0 }
    fn command_results() -&gt; &amp;'static [ResultSpec&lt;&amp;'static str&gt;] { &amp;REVERSE_SPEC.1 }
}

// Step 4: Implement FromAttributes
impl FromAttributes for ReverseCommand {
    fn from_attributes(attrs: &amp;Attributes) -&gt; Result&lt;Self&gt; {
        let input = attrs.get_required_string("input")?;
        Ok(ReverseCommand { input })
    }
}

// Step 5: Implement Executable
#[async_trait]
impl Executable for ReverseCommand {
    async fn execute(&amp;self, context: &amp;ExecutionContext, output_prefix: &amp;StorePath) -&gt; Result&lt;()&gt; {
        let resolved = context.substitute(&amp;self.input).await?;
        let reversed: String = resolved.chars().rev().collect();
        let length = resolved.chars().count() as u64;

        let out = InsertBatch::new(context, output_prefix);
        out.string("reversed", reversed).await?;
        out.u64("length", length).await?;

        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<p>Let’s break this down step by step, starting with <a href="#defining-the-schema">defining the schema</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="defining-the-schema"><a class="header" href="#defining-the-schema">Defining the Schema</a></h1>
<p>Every command in Panopticon has a <strong>schema</strong> that declares:</p>
<ul>
<li>What <strong>attributes</strong> (inputs) it accepts</li>
<li>What <strong>results</strong> (outputs) it produces</li>
</ul>
<p>The schema is validated once when the command is first used, catching configuration errors early rather than at runtime.</p>
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<p>First, import everything you need from the <code>extend</code> module:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::extend::*;
use panopticon_core::prelude::*;
<span class="boring">}</span></code></pre>
<p>The <code>extend</code> module provides all the types needed to build custom commands:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>CommandSpecBuilder</code></td><td>Builds the command schema</td></tr>
<tr><td><code>AttributeSpecBuilder</code></td><td>Builds individual attribute specifications</td></tr>
<tr><td><code>TypeDef</code></td><td>Defines the type of an attribute or result</td></tr>
<tr><td><code>ScalarType</code></td><td>Primitive types (String, Number, Bool, etc.)</td></tr>
<tr><td><code>ReferenceKind</code></td><td>How template references are handled</td></tr>
<tr><td><code>ResultKind</code></td><td>Whether a result is Data or Meta</td></tr>
<tr><td><code>CommandSchema</code></td><td>Type alias for the schema tuple</td></tr>
<tr><td><code>LazyLock</code></td><td>Re-exported for static initialization</td></tr>
</tbody>
</table>
</div>
<h2 id="the-commandschema-type"><a class="header" href="#the-commandschema-type">The CommandSchema Type</a></h2>
<p>A <code>CommandSchema</code> is a type alias for:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type CommandSchema = (Vec&lt;AttributeSpec&lt;&amp;'static str&gt;&gt;, Vec&lt;ResultSpec&lt;&amp;'static str&gt;&gt;);
<span class="boring">}</span></code></pre>
<p>It’s a tuple of attribute specifications and result specifications. We wrap it in a <code>LazyLock</code> so validation runs exactly once, the first time the command is used:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static REVERSE_SPEC: CommandSchema = LazyLock::new(|| {
    // Build and return the schema here
});
<span class="boring">}</span></code></pre>
<h2 id="building-the-schema"><a class="header" href="#building-the-schema">Building the Schema</a></h2>
<h3 id="starting-the-builder"><a class="header" href="#starting-the-builder">Starting the Builder</a></h3>
<p>Create a new <code>CommandSpecBuilder</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static REVERSE_SPEC: CommandSchema = LazyLock::new(|| {
    CommandSpecBuilder::new()
        // ... add attributes and results ...
        .build()
});
<span class="boring">}</span></code></pre>
<p>The <code>build()</code> method at the end:</p>
<ol>
<li>Validates all attribute and result names against the <code>NamePolicy</code></li>
<li>Checks that derived results reference valid attributes (if any)</li>
<li>Returns the tuple <code>(Vec&lt;AttributeSpec&gt;, Vec&lt;ResultSpec&gt;)</code></li>
</ol>
<h3 id="adding-attributes-with-attributespecbuilder"><a class="header" href="#adding-attributes-with-attributespecbuilder">Adding Attributes with AttributeSpecBuilder</a></h3>
<p>Attributes define the inputs your command accepts. Use <code>AttributeSpecBuilder</code> to create them:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>CommandSpecBuilder::new()
    .attribute(
        AttributeSpecBuilder::new("input", TypeDef::Scalar(ScalarType::String))
            .required()
            .hint("String to reverse (supports Tera template substitution)")
            .reference(ReferenceKind::StaticTeraTemplate)
            .build(),
    )
    // ...
<span class="boring">}</span></code></pre>
<p>Let’s examine each method:</p>
<h4 id="attributespecbuildernewname-type_def"><a class="header" href="#attributespecbuildernewname-type_def"><code>AttributeSpecBuilder::new(name, type_def)</code></a></h4>
<p>Creates a new attribute builder with:</p>
<ul>
<li><strong>name</strong>: The attribute name (must follow <code>NamePolicy</code> - alphanumeric and underscores only)</li>
<li><strong>type_def</strong>: The expected type of the attribute value</li>
</ul>
<p>Common <code>TypeDef</code> variants:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Primitive types
TypeDef::Scalar(ScalarType::String)
TypeDef::Scalar(ScalarType::Number)
TypeDef::Scalar(ScalarType::Bool)

// Tabular data (DataFrames)
TypeDef::Tabular

// Arrays
TypeDef::ArrayOf(Box::new(TypeDef::Scalar(ScalarType::String)))

// Objects with specific fields (covered in Spec System docs)
TypeDef::ObjectOf { fields: vec![...] }
<span class="boring">}</span></code></pre>
<h4 id="required"><a class="header" href="#required"><code>.required()</code></a></h4>
<p>Marks the attribute as required. The pipeline will fail validation if this attribute is not provided:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AttributeSpecBuilder::new("input", TypeDef::Scalar(ScalarType::String))
    .required()  // Pipeline fails if "input" is missing
<span class="boring">}</span></code></pre>
<p>If you don’t call <code>.required()</code>, the attribute is optional.</p>
<h4 id="hintdescription"><a class="header" href="#hintdescription"><code>.hint(description)</code></a></h4>
<p>Provides a human-readable description. This appears in documentation and error messages:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.hint("String to reverse (supports Tera template substitution)")
<span class="boring">}</span></code></pre>
<h4 id="referencekind"><a class="header" href="#referencekind"><code>.reference(kind)</code></a></h4>
<p>Specifies how the attribute handles references to other values in the store:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.reference(ReferenceKind::StaticTeraTemplate)
<span class="boring">}</span></code></pre>
<p>The <code>ReferenceKind</code> variants are:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Kind</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>StaticTeraTemplate</code></td><td>Value can contain Tera templates like <code>{{ ns.value }}</code></td></tr>
<tr><td><code>RuntimeTeraTemplate</code></td><td>Treated as a Tera template at runtime (for conditions)</td></tr>
<tr><td><code>StorePath</code></td><td>Value is a direct reference to a store path</td></tr>
<tr><td><code>Unsupported</code></td><td>No reference resolution (default)</td></tr>
</tbody>
</table>
</div>
<p>For our <code>ReverseCommand</code>, we use <code>StaticTeraTemplate</code> so users can write:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The input can reference values from other namespaces
let attrs = ObjectBuilder::new()
    .insert("input", "{{ inputs.greeting }}")
    .build_hashmap();
<span class="boring">}</span></code></pre>
<h4 id="default_valuescalar"><a class="header" href="#default_valuescalar"><code>.default_value(scalar)</code></a></h4>
<p>Provides a default value if the attribute is not specified:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AttributeSpecBuilder::new("separator", TypeDef::Scalar(ScalarType::String))
    .default_value(ScalarValue::String(",".to_string()))
    .build()
<span class="boring">}</span></code></pre>
<h4 id="build"><a class="header" href="#build"><code>.build()</code></a></h4>
<p>Finalizes the <code>AttributeSpec</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.build()  // Returns AttributeSpec&lt;&amp;'static str&gt;
<span class="boring">}</span></code></pre>
<h3 id="adding-results"><a class="header" href="#adding-results">Adding Results</a></h3>
<p>Results define what outputs your command produces. Use <code>fixed_result()</code> for known output names:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>CommandSpecBuilder::new()
    .attribute(/* ... */)
    .fixed_result(
        "reversed",                           // Result name
        TypeDef::Scalar(ScalarType::String),  // Result type
        Some("The reversed string"),          // Optional hint
        ResultKind::Data,                     // Data or Meta
    )
    .fixed_result(
        "length",
        TypeDef::Scalar(ScalarType::Number),
        Some("Character count of the input"),
        ResultKind::Meta,
    )
    .build()
<span class="boring">}</span></code></pre>
<h4 id="result-names"><a class="header" href="#result-names">Result Names</a></h4>
<p>Result names follow the same <code>NamePolicy</code> as attributes:</p>
<ul>
<li>Alphanumeric characters and underscores only</li>
<li>Cannot be reserved names (<code>item</code>, <code>index</code>)</li>
</ul>
<h4 id="resultkind"><a class="header" href="#resultkind">ResultKind</a></h4>
<p>The <code>ResultKind</code> indicates how the result should be treated:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Kind</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>ResultKind::Data</code></td><td>Primary output data (the “answer”)</td></tr>
<tr><td><code>ResultKind::Meta</code></td><td>Metadata about the operation (counts, timing, status)</td></tr>
</tbody>
</table>
</div>
<p>This distinction helps when retrieving results - you can fetch just data results or just metadata.</p>
<h2 id="the-complete-schema"><a class="header" href="#the-complete-schema">The Complete Schema</a></h2>
<p>Here’s our complete schema for <code>ReverseCommand</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::extend::*;
use panopticon_core::prelude::*;

static REVERSE_SPEC: CommandSchema = LazyLock::new(|| {
    CommandSpecBuilder::new()
        // Define the "input" attribute
        .attribute(
            AttributeSpecBuilder::new("input", TypeDef::Scalar(ScalarType::String))
                .required()
                .hint("String to reverse (supports Tera template substitution)")
                .reference(ReferenceKind::StaticTeraTemplate)
                .build(),
        )
        // Define the "reversed" result (primary output)
        .fixed_result(
            "reversed",
            TypeDef::Scalar(ScalarType::String),
            Some("The reversed string"),
            ResultKind::Data,
        )
        // Define the "length" result (metadata)
        .fixed_result(
            "length",
            TypeDef::Scalar(ScalarType::Number),
            Some("Character count of the input"),
            ResultKind::Meta,
        )
        .build()
});
<span class="boring">}</span></code></pre>
<h2 id="common-results-added-automatically"><a class="header" href="#common-results-added-automatically">Common Results Added Automatically</a></h2>
<p>Every command automatically receives these common results (you don’t need to declare them):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Result</th><th>Type</th><th>Kind</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>status</code></td><td>String</td><td>Meta</td><td>Execution status: <code>success</code>, <code>skipped</code>, <code>error</code>, <code>cancelled</code></td></tr>
<tr><td><code>duration_ms</code></td><td>Number</td><td>Meta</td><td>Execution time in milliseconds</td></tr>
</tbody>
</table>
</div>
<p>These are injected by the <code>ExecutableWrapper</code> that wraps your command.</p>
<h2 id="schema-validation"><a class="header" href="#schema-validation">Schema Validation</a></h2>
<p>When <code>build()</code> is called, Panopticon validates:</p>
<ol>
<li><strong>Name Policy</strong>: All names must be alphanumeric + underscore, and not reserved</li>
<li><strong>Derived Results</strong>: If using <code>derived_result()</code>, the referenced attribute must exist and be <code>ArrayOf(ObjectOf)</code></li>
<li><strong>No Duplicates</strong>: Attribute and result names must be unique</li>
</ol>
<p>If validation fails, the program panics with a descriptive error message. This happens at initialization time (when the <code>LazyLock</code> is first accessed), not at runtime.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that we have our schema defined, let’s <a href="#implementing-traits">implement the traits</a> that make the command work.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="implementing-traits"><a class="header" href="#implementing-traits">Implementing Traits</a></h1>
<p>With the schema defined, we need to implement three traits to make our command functional:</p>
<ol>
<li><strong><code>Descriptor</code></strong> - Links the struct to its schema</li>
<li><strong><code>FromAttributes</code></strong> - Parses attributes into struct fields</li>
<li><strong><code>Executable</code></strong> - Performs the actual work</li>
</ol>
<p>Together, these traits satisfy the <code>Command</code> trait, which is a blanket implementation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// You don't implement Command directly - it's automatic
pub trait Command: FromAttributes + Descriptor + Executable {}
impl&lt;T: FromAttributes + Descriptor + Executable&gt; Command for T {}
<span class="boring">}</span></code></pre>
<h2 id="the-command-struct"><a class="header" href="#the-command-struct">The Command Struct</a></h2>
<p>First, define a struct to hold the parsed attribute values:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ReverseCommand {
    input: String,
}
<span class="boring">}</span></code></pre>
<p>The struct fields correspond to the attributes we defined in our schema. In this case, we have one attribute (<code>input</code>) that we’ll store as a <code>String</code>.</p>
<p><strong>Design tip</strong>: Store the raw attribute values in your struct. Template substitution (resolving <code>{{ ... }}</code> references) happens later in <code>execute()</code>, not during construction.</p>
<h2 id="implementing-descriptor"><a class="header" href="#implementing-descriptor">Implementing Descriptor</a></h2>
<p>The <code>Descriptor</code> trait connects your struct to its schema:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Descriptor for ReverseCommand {
    fn command_type() -&gt; &amp;'static str {
        "ReverseCommand"
    }

    fn command_attributes() -&gt; &amp;'static [AttributeSpec&lt;&amp;'static str&gt;] {
        &amp;REVERSE_SPEC.0
    }

    fn command_results() -&gt; &amp;'static [ResultSpec&lt;&amp;'static str&gt;] {
        &amp;REVERSE_SPEC.1
    }
}
<span class="boring">}</span></code></pre>
<h3 id="method-breakdown"><a class="header" href="#method-breakdown">Method Breakdown</a></h3>
<h4 id="command_type"><a class="header" href="#command_type"><code>command_type()</code></a></h4>
<p>Returns a unique identifier for this command type. This is used in logging, error messages, and internally for command registration:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn command_type() -&gt; &amp;'static str {
    "ReverseCommand"
}
<span class="boring">}</span></code></pre>
<p>Convention: Use the struct name as the command type.</p>
<h4 id="command_attributes"><a class="header" href="#command_attributes"><code>command_attributes()</code></a></h4>
<p>Returns the attribute specifications from the schema. Since <code>CommandSchema</code> is a tuple <code>(attributes, results)</code>, we return the first element:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn command_attributes() -&gt; &amp;'static [AttributeSpec&lt;&amp;'static str&gt;] {
    &amp;REVERSE_SPEC.0  // .0 is the attributes vector
}
<span class="boring">}</span></code></pre>
<h4 id="command_results"><a class="header" href="#command_results"><code>command_results()</code></a></h4>
<p>Returns the result specifications from the schema:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn command_results() -&gt; &amp;'static [ResultSpec&lt;&amp;'static str&gt;] {
    &amp;REVERSE_SPEC.1  // .1 is the results vector
}
<span class="boring">}</span></code></pre>
<h3 id="default-methods"><a class="header" href="#default-methods">Default Methods</a></h3>
<p><code>Descriptor</code> provides several default methods you get for free:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All attributes (including common ones like "when")
fn available_attributes() -&gt; Vec&lt;&amp;'static AttributeSpec&lt;&amp;'static str&gt;&gt;

// Only required attributes
fn required_attributes() -&gt; Vec&lt;&amp;'static AttributeSpec&lt;&amp;'static str&gt;&gt;

// Only optional attributes
fn optional_attributes() -&gt; Vec&lt;&amp;'static AttributeSpec&lt;&amp;'static str&gt;&gt;

// All results (including common ones like "status", "duration_ms")
fn available_results() -&gt; Vec&lt;&amp;'static ResultSpec&lt;&amp;'static str&gt;&gt;
<span class="boring">}</span></code></pre>
<h2 id="implementing-fromattributes"><a class="header" href="#implementing-fromattributes">Implementing FromAttributes</a></h2>
<p>The <code>FromAttributes</code> trait constructs your command from the provided attributes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FromAttributes for ReverseCommand {
    fn from_attributes(attrs: &amp;Attributes) -&gt; Result&lt;Self&gt; {
        let input = attrs.get_required_string("input")?;
        Ok(ReverseCommand { input })
    }
}
<span class="boring">}</span></code></pre>
<h3 id="the-attributes-type"><a class="header" href="#the-attributes-type">The Attributes Type</a></h3>
<p><code>Attributes</code> is a type alias for <code>HashMap&lt;String, ScalarValue&gt;</code>. The <code>ScalarMapExt</code> trait (automatically available via imports) provides helper methods:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Required getters - return Err if missing or wrong type
attrs.get_required_string("key")?    // -&gt; String
attrs.get_required_i64("key")?       // -&gt; i64
attrs.get_required_bool("key")?      // -&gt; bool
attrs.get_required("key")?           // -&gt; &amp;ScalarValue

// Optional getters - return None if missing
attrs.get_optional_string("key")     // -&gt; Option&lt;String&gt;
attrs.get_optional_i64("key")        // -&gt; Option&lt;i64&gt;
attrs.get_optional_bool("key")       // -&gt; Option&lt;bool&gt;
attrs.get("key")                     // -&gt; Option&lt;&amp;ScalarValue&gt;
<span class="boring">}</span></code></pre>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p>The <code>?</code> operator propagates errors with descriptive messages:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// If "input" is missing, this returns:
// Err(anyhow::Error: missing required key 'input')
let input = attrs.get_required_string("input")?;

// If "count" is present but not an integer:
// Err(anyhow::Error: 'count' must be an integer)
let count = attrs.get_required_i64("count")?;
<span class="boring">}</span></code></pre>
<h3 id="working-with-complex-types"><a class="header" href="#working-with-complex-types">Working with Complex Types</a></h3>
<p>For optional attributes with defaults:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let separator = attrs.get_optional_string("separator")
    .unwrap_or_else(|| ",".to_string());
<span class="boring">}</span></code></pre>
<p>For arrays:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let values = attrs.get_required("items")?
    .as_array_or_err("items")?
    .iter()
    .map(|v| v.as_str_or_err("items[i]").map(String::from))
    .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
<span class="boring">}</span></code></pre>
<h3 id="the-scalarasext-trait"><a class="header" href="#the-scalarasext-trait">The ScalarAsExt Trait</a></h3>
<p>When you have a <code>ScalarValue</code> and need to convert it to a specific type, use <code>ScalarAsExt</code> methods:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value: &amp;ScalarValue = attrs.get_required("field")?;

// These return Result with helpful error messages
value.as_str_or_err("field")?       // -&gt; &amp;str
value.as_i64_or_err("field")?       // -&gt; i64
value.as_f64_or_err("field")?       // -&gt; f64
value.as_bool_or_err("field")?      // -&gt; bool
value.as_array_or_err("field")?     // -&gt; &amp;Vec&lt;ScalarValue&gt;
value.as_object_or_err("field")?    // -&gt; &amp;Map&lt;String, ScalarValue&gt;
<span class="boring">}</span></code></pre>
<h3 id="default-method-extract_dependencies"><a class="header" href="#default-method-extract_dependencies">Default Method: extract_dependencies</a></h3>
<p><code>FromAttributes</code> provides a default implementation of <code>extract_dependencies()</code> that automatically parses Tera templates in attribute values to find store path references:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn extract_dependencies(attrs: &amp;Attributes) -&gt; Result&lt;HashSet&lt;StorePath&gt;&gt; {
    // Automatically implemented based on ReferenceKind in your schema
}
<span class="boring">}</span></code></pre>
<p>This is used internally to build the dependency graph for execution ordering.</p>
<h2 id="implementing-executable"><a class="header" href="#implementing-executable">Implementing Executable</a></h2>
<p>The <code>Executable</code> trait defines what your command actually does:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
impl Executable for ReverseCommand {
    async fn execute(
        &amp;self,
        context: &amp;ExecutionContext,
        output_prefix: &amp;StorePath,
    ) -&gt; Result&lt;()&gt; {
        // 1. Resolve any Tera templates in the input
        let resolved = context.substitute(&amp;self.input).await?;

        // 2. Perform the business logic
        let reversed: String = resolved.chars().rev().collect();
        let length = resolved.chars().count() as u64;

        // 3. Write results to the store
        let out = InsertBatch::new(context, output_prefix);
        out.string("reversed", reversed).await?;
        out.u64("length", length).await?;

        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="the-async_trait-macro"><a class="header" href="#the-async_trait-macro">The async_trait Macro</a></h3>
<p>Since <code>Executable</code> is an async trait, you need the <code>#[async_trait]</code> attribute:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::extend::async_trait;  // Re-exported for convenience

#[async_trait]
impl Executable for ReverseCommand {
    async fn execute(&amp;self, context: &amp;ExecutionContext, output_prefix: &amp;StorePath) -&gt; Result&lt;()&gt; {
        // ...
    }
}
<span class="boring">}</span></code></pre>
<h3 id="method-parameters"><a class="header" href="#method-parameters">Method Parameters</a></h3>
<h4 id="self"><a class="header" href="#self"><code>&amp;self</code></a></h4>
<p>Your command instance with parsed attribute values. This was created by <code>from_attributes()</code>.</p>
<h4 id="context-executioncontext"><a class="header" href="#context-executioncontext"><code>context: &amp;ExecutionContext</code></a></h4>
<p>The execution context provides:</p>
<ul>
<li><strong>Template substitution</strong>: <code>context.substitute(&amp;template).await?</code></li>
<li><strong>Scalar store access</strong>: <code>context.scalar()</code> for reading/writing scalar values</li>
<li><strong>Tabular store access</strong>: <code>context.tabular()</code> for reading/writing DataFrames</li>
<li><strong>Extensions</strong>: <code>context.extensions()</code> for cancellation checks and custom services</li>
</ul>
<h4 id="output_prefix-storepath"><a class="header" href="#output_prefix-storepath"><code>output_prefix: &amp;StorePath</code></a></h4>
<p>The store path where this command should write its results. For a command named <code>reverse</code> in namespace <code>demo</code>, this would be <code>demo.reverse</code>.</p>
<p>Your results should be written as children of this prefix:</p>
<ul>
<li><code>demo.reverse.reversed</code></li>
<li><code>demo.reverse.length</code></li>
</ul>
<h3 id="template-substitution"><a class="header" href="#template-substitution">Template Substitution</a></h3>
<p>If your attribute supports Tera templates (<code>ReferenceKind::StaticTeraTemplate</code>), resolve them using <code>context.substitute()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// self.input might be "{{ inputs.greeting }}"
let resolved = context.substitute(&amp;self.input).await?;
// resolved is now "Hello, world!" (the actual value from the store)
<span class="boring">}</span></code></pre>
<p>This is crucial - without substitution, you’d operate on the literal template string.</p>
<h3 id="writing-results-with-insertbatch"><a class="header" href="#writing-results-with-insertbatch">Writing Results with InsertBatch</a></h3>
<p><code>InsertBatch</code> provides a convenient API for writing results under the output prefix:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let out = InsertBatch::new(context, output_prefix);

// Write different types
out.string("name", "value".to_string()).await?;
out.i64("count", 42).await?;
out.u64("size", 100).await?;
out.f64("ratio", 0.75).await?;
out.bool("success", true).await?;
out.null("empty").await?;

// Write arbitrary ScalarValue
out.scalar("data", some_scalar_value).await?;

// Write tabular data
out.tabular("table", dataframe).await?;
<span class="boring">}</span></code></pre>
<p>Each method writes to <code>output_prefix.segment</code>. For example, with <code>output_prefix = demo.reverse</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>out.string("reversed", reversed).await?;  // Writes to demo.reverse.reversed
out.u64("length", length).await?;          // Writes to demo.reverse.length
<span class="boring">}</span></code></pre>
<h3 id="checking-for-cancellation"><a class="header" href="#checking-for-cancellation">Checking for Cancellation</a></h3>
<p>For long-running commands, periodically check if the pipeline was cancelled:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
impl Executable for LongRunningCommand {
    async fn execute(&amp;self, context: &amp;ExecutionContext, output_prefix: &amp;StorePath) -&gt; Result&lt;()&gt; {
        for item in items {
            // Check cancellation before each iteration
            if context.extensions().is_canceled().await {
                return Ok(());  // Exit gracefully
            }

            // Process item...
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="return-value"><a class="header" href="#return-value">Return Value</a></h3>
<p>Return <code>Ok(())</code> on success. The wrapper automatically sets:</p>
<ul>
<li><code>status</code> to <code>"success"</code></li>
<li><code>duration_ms</code> to the execution time</li>
</ul>
<p>Return <code>Err(...)</code> on failure. The wrapper automatically sets:</p>
<ul>
<li><code>status</code> to <code>"error"</code></li>
<li><code>duration_ms</code> to the execution time</li>
</ul>
<p>The error is propagated up to the pipeline.</p>
<h2 id="complete-implementation"><a class="header" href="#complete-implementation">Complete Implementation</a></h2>
<p>Here’s everything together:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::extend::*;
use panopticon_core::prelude::*;

// Schema (from previous section)
static REVERSE_SPEC: CommandSchema = LazyLock::new(|| {
    CommandSpecBuilder::new()
        .attribute(
            AttributeSpecBuilder::new("input", TypeDef::Scalar(ScalarType::String))
                .required()
                .hint("String to reverse (supports Tera template substitution)")
                .reference(ReferenceKind::StaticTeraTemplate)
                .build(),
        )
        .fixed_result(
            "reversed",
            TypeDef::Scalar(ScalarType::String),
            Some("The reversed string"),
            ResultKind::Data,
        )
        .fixed_result(
            "length",
            TypeDef::Scalar(ScalarType::Number),
            Some("Character count of the input"),
            ResultKind::Meta,
        )
        .build()
});

// Command struct
pub struct ReverseCommand {
    input: String,
}

// Descriptor implementation
impl Descriptor for ReverseCommand {
    fn command_type() -&gt; &amp;'static str {
        "ReverseCommand"
    }

    fn command_attributes() -&gt; &amp;'static [AttributeSpec&lt;&amp;'static str&gt;] {
        &amp;REVERSE_SPEC.0
    }

    fn command_results() -&gt; &amp;'static [ResultSpec&lt;&amp;'static str&gt;] {
        &amp;REVERSE_SPEC.1
    }
}

// FromAttributes implementation
impl FromAttributes for ReverseCommand {
    fn from_attributes(attrs: &amp;Attributes) -&gt; Result&lt;Self&gt; {
        let input = attrs.get_required_string("input")?;
        Ok(ReverseCommand { input })
    }
}

// Executable implementation
#[async_trait]
impl Executable for ReverseCommand {
    async fn execute(
        &amp;self,
        context: &amp;ExecutionContext,
        output_prefix: &amp;StorePath,
    ) -&gt; Result&lt;()&gt; {
        // Resolve Tera templates
        let resolved = context.substitute(&amp;self.input).await?;

        // Business logic
        let reversed: String = resolved.chars().rev().collect();
        let length = resolved.chars().count() as u64;

        // Write results
        let out = InsertBatch::new(context, output_prefix);
        out.string("reversed", reversed).await?;
        out.u64("length", length).await?;

        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Our command is complete. Now let’s <a href="#testing-your-command">test it in a pipeline</a> to see it in action.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="testing-your-command"><a class="header" href="#testing-your-command">Testing Your Command</a></h1>
<p>With our <code>ReverseCommand</code> fully implemented, let’s integrate it into a pipeline and verify it works correctly.</p>
<h2 id="creating-the-pipeline"><a class="header" href="#creating-the-pipeline">Creating the Pipeline</a></h2>
<h3 id="basic-setup"><a class="header" href="#basic-setup">Basic Setup</a></h3>
<p>Start by creating a pipeline and adding your command:</p>
<pre class="playground"><code class="language-rust">use panopticon_core::extend::*;
use panopticon_core::prelude::*;

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    // Create a new pipeline
    let mut pipeline = Pipeline::new();

    // Add a namespace for our command
    pipeline
        .add_namespace(NamespaceBuilder::new("demo"))
        .await?;

    // Add the command with attributes
    let attrs = ObjectBuilder::new()
        .insert("input", "Hello, world!")
        .build_hashmap();

    pipeline
        .add_command::&lt;ReverseCommand&gt;("reverse", &amp;attrs)
        .await?;

    // Compile and execute
    let completed = pipeline.compile().await?.execute().await?;

    Ok(())
}</code></pre>
<h3 id="using-objectbuilder-for-attributes"><a class="header" href="#using-objectbuilder-for-attributes">Using ObjectBuilder for Attributes</a></h3>
<p><code>ObjectBuilder</code> provides a fluent API for constructing attribute maps:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let attrs = ObjectBuilder::new()
    .insert("input", "Hello, world!")        // String value
    .insert("count", 42)                      // Number value
    .insert("enabled", true)                  // Boolean value
    .build_hashmap();                         // -&gt; HashMap&lt;String, ScalarValue&gt;
<span class="boring">}</span></code></pre>
<p>The <code>build_hashmap()</code> method converts the builder into the <code>Attributes</code> type expected by <code>add_command()</code>.</p>
<h2 id="using-tera-templates"><a class="header" href="#using-tera-templates">Using Tera Templates</a></h2>
<p>One of Panopticon’s powerful features is referencing values from other namespaces using Tera templates.</p>
<h3 id="setting-up-static-input-data"><a class="header" href="#setting-up-static-input-data">Setting Up Static Input Data</a></h3>
<p>Create a static namespace with seed values:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pipeline
    .add_namespace(
        NamespaceBuilder::new("inputs")
            .static_ns()  // Mark as static (no commands, just data)
            .insert("greeting", ScalarValue::String("Hello, world!".to_string())),
    )
    .await?;
<span class="boring">}</span></code></pre>
<h3 id="referencing-values-in-templates"><a class="header" href="#referencing-values-in-templates">Referencing Values in Templates</a></h3>
<p>Now reference that value in your command:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pipeline
    .add_namespace(NamespaceBuilder::new("demo"))
    .await?;

// Use Tera template syntax to reference the static value
let attrs = ObjectBuilder::new()
    .insert("input", "{{ inputs.greeting }}")
    .build_hashmap();

pipeline
    .add_command::&lt;ReverseCommand&gt;("reverse", &amp;attrs)
    .await?;
<span class="boring">}</span></code></pre>
<p>When <code>execute()</code> runs, <code>context.substitute(&amp;self.input)</code> resolves <code>{{ inputs.greeting }}</code> to <code>"Hello, world!"</code>.</p>
<h2 id="executing-the-pipeline"><a class="header" href="#executing-the-pipeline">Executing the Pipeline</a></h2>
<h3 id="the-pipeline-lifecycle"><a class="header" href="#the-pipeline-lifecycle">The Pipeline Lifecycle</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Build phase - add namespaces and commands
let mut pipeline = Pipeline::new();
// ... add namespaces and commands ...

// 2. Compile phase - validate and build execution plan
let ready = pipeline.compile().await?;

// 3. Execute phase - run all commands in dependency order
let completed = ready.execute().await?;
<span class="boring">}</span></code></pre>
<h3 id="accessing-results"><a class="header" href="#accessing-results">Accessing Results</a></h3>
<p>After execution, retrieve results using the <code>ResultStore</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let results = completed.results(ResultSettings::default()).await?;
<span class="boring">}</span></code></pre>
<h3 id="querying-by-source-path"><a class="header" href="#querying-by-source-path">Querying by Source Path</a></h3>
<p>Each command’s results are stored under its source path (<code>namespace.command_name</code>):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Build the source path
let source = StorePath::from_segments(["demo", "reverse"]);

// Get all results for this command
let cmd_results = results
    .get_by_source(&amp;source)
    .expect("Expected demo.reverse results");
<span class="boring">}</span></code></pre>
<h3 id="retrieving-individual-results"><a class="header" href="#retrieving-individual-results">Retrieving Individual Results</a></h3>
<h4 id="data-results"><a class="header" href="#data-results">Data Results</a></h4>
<p>Use <code>data_get()</code> for results marked as <code>ResultKind::Data</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let reversed = cmd_results
    .data_get(&amp;source.with_segment("reversed"))
    .and_then(|r| r.as_scalar())
    .expect("Expected reversed result");

// reversed is a tuple: (StorePath, &amp;ScalarValue)
println!("Reversed: {}", reversed.1);
<span class="boring">}</span></code></pre>
<h4 id="metadata-results"><a class="header" href="#metadata-results">Metadata Results</a></h4>
<p>Use <code>meta_get()</code> for results marked as <code>ResultKind::Meta</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let length = cmd_results
    .meta_get(&amp;source.with_segment("length"))
    .expect("Expected length metadata");

println!("Length: {}", length);

// Common metadata (automatically added)
let status = cmd_results
    .meta_get(&amp;source.with_segment("status"))
    .expect("Expected status");

let duration = cmd_results
    .meta_get(&amp;source.with_segment("duration_ms"))
    .expect("Expected duration");

println!("Status: {}", status);
println!("Duration: {}ms", duration);
<span class="boring">}</span></code></pre>
<h2 id="complete-working-example"><a class="header" href="#complete-working-example">Complete Working Example</a></h2>
<p>Here’s the full example that demonstrates everything:</p>
<pre class="playground"><code class="language-rust">//! Example: Implementing a custom Command
//!
//! Run with: cargo run --example custom_command

use panopticon_core::extend::*;
use panopticon_core::prelude::*;

// ─── Schema Definition ─────────────────────────────────────────────────────

static REVERSE_SPEC: CommandSchema = LazyLock::new(|| {
    CommandSpecBuilder::new()
        .attribute(
            AttributeSpecBuilder::new("input", TypeDef::Scalar(ScalarType::String))
                .required()
                .hint("String to reverse (supports Tera template substitution)")
                .reference(ReferenceKind::StaticTeraTemplate)
                .build(),
        )
        .fixed_result(
            "reversed",
            TypeDef::Scalar(ScalarType::String),
            Some("The reversed string"),
            ResultKind::Data,
        )
        .fixed_result(
            "length",
            TypeDef::Scalar(ScalarType::Number),
            Some("Character count of the input"),
            ResultKind::Meta,
        )
        .build()
});

// ─── Command Struct ────────────────────────────────────────────────────────

pub struct ReverseCommand {
    input: String,
}

// ─── Descriptor ────────────────────────────────────────────────────────────

impl Descriptor for ReverseCommand {
    fn command_type() -&gt; &amp;'static str {
        "ReverseCommand"
    }

    fn command_attributes() -&gt; &amp;'static [AttributeSpec&lt;&amp;'static str&gt;] {
        &amp;REVERSE_SPEC.0
    }

    fn command_results() -&gt; &amp;'static [ResultSpec&lt;&amp;'static str&gt;] {
        &amp;REVERSE_SPEC.1
    }
}

// ─── FromAttributes ────────────────────────────────────────────────────────

impl FromAttributes for ReverseCommand {
    fn from_attributes(attrs: &amp;Attributes) -&gt; Result&lt;Self&gt; {
        let input = attrs.get_required_string("input")?;
        Ok(ReverseCommand { input })
    }
}

// ─── Executable ────────────────────────────────────────────────────────────

#[async_trait]
impl Executable for ReverseCommand {
    async fn execute(
        &amp;self,
        context: &amp;ExecutionContext,
        output_prefix: &amp;StorePath,
    ) -&gt; Result&lt;()&gt; {
        // Resolve any Tera templates in the input
        let resolved = context.substitute(&amp;self.input).await?;

        // Perform the transformation
        let reversed: String = resolved.chars().rev().collect();
        let length = resolved.chars().count() as u64;

        // Write results
        let out = InsertBatch::new(context, output_prefix);
        out.string("reversed", reversed).await?;
        out.u64("length", length).await?;

        Ok(())
    }
}

// ─── Pipeline Demo ─────────────────────────────────────────────────────────

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    // Create the pipeline
    let mut pipeline = Pipeline::new();

    // Add static input data
    pipeline
        .add_namespace(
            NamespaceBuilder::new("inputs")
                .static_ns()
                .insert("greeting", ScalarValue::String("Hello, world!".to_string())),
        )
        .await?;

    // Add namespace with our custom command
    pipeline
        .add_namespace(NamespaceBuilder::new("demo"))
        .await?;

    // Configure the command with a Tera template reference
    let attrs = ObjectBuilder::new()
        .insert("input", "{{ inputs.greeting }}")
        .build_hashmap();

    pipeline
        .add_command::&lt;ReverseCommand&gt;("reverse", &amp;attrs)
        .await?;

    // Execute the pipeline
    let completed = pipeline.compile().await?.execute().await?;
    let results = completed.results(ResultSettings::default()).await?;

    // Retrieve and display results
    let source = StorePath::from_segments(["demo", "reverse"]);
    let cmd_results = results
        .get_by_source(&amp;source)
        .expect("Expected demo.reverse results");

    // Get the reversed string (Data result)
    let reversed = cmd_results
        .data_get(&amp;source.with_segment("reversed"))
        .and_then(|r| r.as_scalar())
        .expect("Expected reversed result");

    // Get metadata
    let length = cmd_results
        .meta_get(&amp;source.with_segment("length"))
        .expect("Expected length metadata");

    let status = cmd_results
        .meta_get(&amp;source.with_segment("status"))
        .expect("Expected status metadata");

    // Print results
    println!("Original: Hello, world!");
    println!("Reversed: {}", reversed.1);
    println!("Length:   {}", length);
    println!("Status:   {}", status);

    Ok(())
}</code></pre>
<h3 id="expected-output"><a class="header" href="#expected-output">Expected Output</a></h3>
<pre><code class="language-text">Original: Hello, world!
Reversed: !dlrow ,olleH
Length:   13
Status:   success
</code></pre>
<h2 id="testing-with-the-when-condition"><a class="header" href="#testing-with-the-when-condition">Testing with the “when” Condition</a></h2>
<p>All commands support a <code>when</code> attribute for conditional execution:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let attrs = ObjectBuilder::new()
    .insert("input", "{{ inputs.greeting }}")
    .insert("when", "inputs.should_run")  // Only run if truthy
    .build_hashmap();
<span class="boring">}</span></code></pre>
<p>If the condition evaluates to false, the command is skipped and <code>status</code> is set to <code>"skipped"</code>.</p>
<h2 id="writing-unit-tests"><a class="header" href="#writing-unit-tests">Writing Unit Tests</a></h2>
<p>For unit testing your command logic:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_reverse_command() {
        let mut pipeline = Pipeline::new();

        pipeline
            .add_namespace(NamespaceBuilder::new("test"))
            .await
            .unwrap();

        let attrs = ObjectBuilder::new()
            .insert("input", "abc")
            .build_hashmap();

        pipeline
            .add_command::&lt;ReverseCommand&gt;("rev", &amp;attrs)
            .await
            .unwrap();

        let completed = pipeline.compile().await.unwrap().execute().await.unwrap();
        let results = completed.results(ResultSettings::default()).await.unwrap();

        let source = StorePath::from_segments(["test", "rev"]);
        let cmd_results = results.get_by_source(&amp;source).unwrap();

        let reversed = cmd_results
            .data_get(&amp;source.with_segment("reversed"))
            .and_then(|r| r.as_scalar())
            .unwrap();

        assert_eq!(reversed.1.as_str().unwrap(), "cba");
    }
}
<span class="boring">}</span></code></pre>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>You have now built a complete custom command that:</p>
<ol>
<li>Declares its schema with <code>CommandSpecBuilder</code> and <code>AttributeSpecBuilder</code></li>
<li>Implements <code>Descriptor</code> to link the struct to its schema</li>
<li>Implements <code>FromAttributes</code> to parse input attributes</li>
<li>Implements <code>Executable</code> to perform the actual work</li>
<li>Integrates with the pipeline for execution and result retrieval</li>
</ol>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<ul>
<li>Learn about the <a href="#spec-system-overview">Spec System</a> for advanced schema features</li>
<li>Explore <a href="#working-with-executioncontext">Working with ExecutionContext</a> for more context capabilities</li>
<li>See <a href="#advanced-patterns">Advanced Patterns</a> for derived results and complex scenarios</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="spec-system-overview"><a class="header" href="#spec-system-overview">Spec System Overview</a></h1>
<p>The spec system is the type-safe schema definition layer for Panopticon commands. It defines what attributes a command accepts, what results it produces, and how those relate to each other. The spec system catches configuration errors at compile time and build time, before they can cause runtime failures.</p>
<h2 id="why-a-spec-system"><a class="header" href="#why-a-spec-system">Why a Spec System?</a></h2>
<p>Pipeline definitions in Panopticon are data-driven (YAML/TOML/JSON), but the commands that execute them are strongly typed Rust code. The spec system bridges this gap by:</p>
<ol>
<li><strong>Defining schemas</strong> that validate pipeline configurations</li>
<li><strong>Enforcing naming rules</strong> that prevent conflicts with internal identifiers</li>
<li><strong>Tracking reference kinds</strong> so the engine knows which fields contain templates or store paths</li>
<li><strong>Providing compile-time safety</strong> for derived result patterns</li>
</ol>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<p>The spec system consists of several interconnected types:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><a href="#type-definitions"><code>TypeDef</code></a></td><td>Describes the shape of data: Scalar, Tabular, ArrayOf, ObjectOf</td></tr>
<tr><td><a href="#reference-kinds"><code>ReferenceKind</code></a></td><td>Indicates how to evaluate a field: literal, template, or store path</td></tr>
<tr><td><a href="#object-fields"><code>ObjectFields</code></a></td><td>Builder for ObjectOf fields with literal/template distinction</td></tr>
<tr><td><a href="#literalfieldref-compile-time-safety"><code>LiteralFieldRef</code></a></td><td>Compile-time proof that a field contains literal data</td></tr>
<tr><td><a href="#name-policy"><code>NamePolicy</code></a></td><td>Validation rules for names: reserved words, forbidden characters</td></tr>
<tr><td><a href="#result-specs"><code>ResultSpec</code></a></td><td>Specification for command outputs: fixed or derived</td></tr>
</tbody>
</table>
</div>
<h2 id="how-the-pieces-fit-together"><a class="header" href="#how-the-pieces-fit-together">How the Pieces Fit Together</a></h2>
<p>Here is a typical flow for defining a command spec:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::extend::*;

// 1. Start the builder
let builder = CommandSpecBuilder::new();

// 2. Define an array-of-objects attribute
let (pending, fields) = builder.array_of_objects(
    "columns",
    true,
    Some("Column definitions")
);

// 3. Add fields using ObjectFields builder
//    - add_literal() returns a LiteralFieldRef
//    - add_template() does not
let (fields, name_ref) = fields.add_literal(
    "name",
    TypeDef::Scalar(ScalarType::String),
    true,
    None
);

let fields = fields.add_template(
    "expression",
    TypeDef::Scalar(ScalarType::String),
    true,
    None,
    ReferenceKind::RuntimeTeraTemplate
);

// 4. Finalize the attribute and add a derived result
let (attributes, results) = pending
    .finalise_attribute(fields)
    .derived_result("columns", name_ref, None, ResultKind::Data)
    .build();
<span class="boring">}</span></code></pre>
<p>The key insight is that <code>derived_result()</code> requires a <code>LiteralFieldRef</code>, and the <strong>only way</strong> to obtain one is through <code>add_literal()</code>. This means the compiler prevents you from using template fields (whose values change at runtime) as result names.</p>
<h2 id="compile-time-vs-build-time-vs-runtime"><a class="header" href="#compile-time-vs-build-time-vs-runtime">Compile-Time vs Build-Time vs Runtime</a></h2>
<p>The spec system provides three levels of validation:</p>
<h3 id="compile-time"><a class="header" href="#compile-time">Compile Time</a></h3>
<p>The type system prevents certain categories of errors entirely:</p>
<ul>
<li>Template fields cannot be passed to <code>derived_result()</code> (no <code>LiteralFieldRef</code> available)</li>
<li>Attribute references must have valid types</li>
</ul>
<h3 id="build-time-spec-construction"><a class="header" href="#build-time-spec-construction">Build Time (spec construction)</a></h3>
<p>When <code>CommandSpecBuilder::build()</code> is called, additional validations run:</p>
<ul>
<li>Derived results must reference existing attributes</li>
<li>Referenced attributes must be <code>ArrayOf(ObjectOf { ... })</code></li>
<li>All names pass <code>NamePolicy</code> validation</li>
</ul>
<h3 id="runtime"><a class="header" href="#runtime">Runtime</a></h3>
<p>During pipeline execution, values are validated against their specs:</p>
<ul>
<li>Required attributes must be present</li>
<li>Types must match expectations</li>
<li>Templates must resolve to valid values</li>
</ul>
<h2 id="example-complete-command-spec"><a class="header" href="#example-complete-command-spec">Example: Complete Command Spec</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::extend::*;

fn define_transform_spec() -&gt; (Vec&lt;AttributeSpec&lt;&amp;'static str&gt;&gt;, Vec&lt;ResultSpec&lt;&amp;'static str&gt;&gt;) {
    // Start with a simple scalar attribute
    let builder = CommandSpecBuilder::new()
        .attribute(
            AttributeSpecBuilder::new("source", TypeDef::Scalar(ScalarType::String))
                .required()
                .reference(ReferenceKind::StorePath)
                .hint("Store path to source data")
                .build()
        );

    // Add an array-of-objects attribute with mixed fields
    let (pending, fields) = builder.array_of_objects(
        "transforms",
        true,
        Some("Transform specifications")
    );

    // Literal field: will be used for result names
    let (fields, name_ref) = fields.add_literal(
        "name",
        TypeDef::Scalar(ScalarType::String),
        true,
        Some("Output name for this transform")
    );

    // Template field: evaluated at runtime
    let fields = fields.add_template(
        "expression",
        TypeDef::Scalar(ScalarType::String),
        true,
        Some("Tera expression to compute the value"),
        ReferenceKind::RuntimeTeraTemplate
    );

    // Build with fixed and derived results
    pending
        .finalise_attribute(fields)
        .fixed_result(
            "metadata",
            TypeDef::Scalar(ScalarType::Object),
            Some("Transform metadata"),
            ResultKind::Meta
        )
        .derived_result(
            "transforms",  // Source attribute
            name_ref,      // Name comes from this literal field
            None,          // Type inferred at runtime
            ResultKind::Data
        )
        .build()
}
<span class="boring">}</span></code></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li><a href="#type-definitions">Type Definitions</a> - Learn about Scalar, Tabular, ArrayOf, and ObjectOf</li>
<li><a href="#reference-kinds">Reference Kinds</a> - Understand when to use each reference type</li>
<li><a href="#object-fields">Object Fields</a> - Master the ObjectFields builder pattern</li>
<li><a href="#literalfieldref-compile-time-safety">LiteralFieldRef</a> - Dive deep into compile-time safety</li>
<li><a href="#name-policy">Name Policy</a> - Avoid naming violations</li>
<li><a href="#result-specs">Result Specs</a> - Fixed vs derived results</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-definitions"><a class="header" href="#type-definitions">Type Definitions</a></h1>
<p>The <code>TypeDef</code> enum describes the shape of data in Panopticon. Every attribute and result has a <code>TypeDef</code> that specifies what kind of data it holds.</p>
<h2 id="the-typedef-enum"><a class="header" href="#the-typedef-enum">The TypeDef Enum</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TypeDef&lt;T: Into&lt;String&gt;&gt; {
    Scalar(ScalarType),
    Tabular,
    ArrayOf(Box&lt;TypeDef&lt;T&gt;&gt;),
    ObjectOf { fields: Vec&lt;FieldSpec&lt;T&gt;&gt; },
}
<span class="boring">}</span></code></pre>
<p>The generic parameter <code>T</code> allows specs to be defined with either <code>&amp;'static str</code> (for compile-time definitions) or <code>String</code> (for runtime use). In practice, you will typically use <code>&amp;'static str</code>.</p>
<h2 id="scalar"><a class="header" href="#scalar">Scalar</a></h2>
<p><code>Scalar</code> represents a single value of a primitive type. The <code>ScalarType</code> enum defines the allowed types:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ScalarType {
    Null,
    Bool,
    Number,
    String,
    Array,   // JSON array (untyped)
    Object,  // JSON object (untyped)
}
<span class="boring">}</span></code></pre>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A required string attribute
TypeDef::Scalar(ScalarType::String)

// A boolean flag
TypeDef::Scalar(ScalarType::Bool)

// A numeric value
TypeDef::Scalar(ScalarType::Number)

// An untyped JSON object (flexible but less validated)
TypeDef::Scalar(ScalarType::Object)
<span class="boring">}</span></code></pre>
<h3 id="when-to-use"><a class="header" href="#when-to-use">When to Use</a></h3>
<p>Use <code>Scalar</code> for:</p>
<ul>
<li>Simple configuration values (paths, names, flags)</li>
<li>Store path references</li>
<li>Template strings</li>
<li>Any single value that is not tabular data</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::extend::*;

let builder = CommandSpecBuilder::new()
    .attribute(
        AttributeSpecBuilder::new("output_path", TypeDef::Scalar(ScalarType::String))
            .required()
            .hint("Path where results will be written")
            .build()
    )
    .attribute(
        AttributeSpecBuilder::new("include_headers", TypeDef::Scalar(ScalarType::Bool))
            .default_value(ScalarValue::Bool(true))
            .build()
    );
<span class="boring">}</span></code></pre>
<h2 id="tabular"><a class="header" href="#tabular">Tabular</a></h2>
<p><code>Tabular</code> represents structured data with rows and columns, like a database table or CSV file. This is Panopticon’s primary data interchange format.</p>
<h3 id="usage-1"><a class="header" href="#usage-1">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TypeDef::Tabular
<span class="boring">}</span></code></pre>
<h3 id="when-to-use-1"><a class="header" href="#when-to-use-1">When to Use</a></h3>
<p>Use <code>Tabular</code> for:</p>
<ul>
<li>Input data to be processed</li>
<li>Output results from queries</li>
<li>Any structured dataset</li>
</ul>
<h3 id="characteristics"><a class="header" href="#characteristics">Characteristics</a></h3>
<ul>
<li>Tabular data has a schema (column names and types)</li>
<li>Can be iterated row by row</li>
<li>Supports filtering, transformation, and aggregation</li>
<li>Used with <code>ReferenceKind::StorePath</code> to reference data in the store</li>
</ul>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Result that produces tabular data
builder.fixed_result(
    "data",
    TypeDef::Tabular,
    Some("Query results as tabular data"),
    ResultKind::Data
)
<span class="boring">}</span></code></pre>
<h2 id="arrayof"><a class="header" href="#arrayof">ArrayOf</a></h2>
<p><code>ArrayOf</code> creates a type representing an array of another type. It is recursive, allowing nested structures.</p>
<h3 id="usage-2"><a class="header" href="#usage-2">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Array of strings
TypeDef::ArrayOf(Box::new(TypeDef::Scalar(ScalarType::String)))

// Array of objects (common pattern)
TypeDef::ArrayOf(Box::new(TypeDef::ObjectOf { fields: vec![...] }))
<span class="boring">}</span></code></pre>
<h3 id="when-to-use-2"><a class="header" href="#when-to-use-2">When to Use</a></h3>
<p>Use <code>ArrayOf</code> for:</p>
<ul>
<li>Lists of configuration items</li>
<li>Multiple input/output specifications</li>
<li>Any repeated structure</li>
</ul>
<h3 id="important-arrayofobjectof-pattern"><a class="header" href="#important-arrayofobjectof-pattern">Important: ArrayOf(ObjectOf) Pattern</a></h3>
<p>The <code>ArrayOf(ObjectOf { ... })</code> pattern is special in Panopticon. It is used for:</p>
<ol>
<li>Defining complex attribute structures with multiple named fields</li>
<li>Enabling <strong>derived results</strong> where each object in the array produces a named output</li>
</ol>
<p>This is the <strong>only</strong> structure that supports <code>derived_result()</code>.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Manual construction (rarely needed)
let fields = vec![
    FieldSpec {
        name: "name",
        ty: TypeDef::Scalar(ScalarType::String),
        required: true,
        hint: Some("Column name"),
        reference_kind: ReferenceKind::Unsupported,
    },
    FieldSpec {
        name: "type",
        ty: TypeDef::Scalar(ScalarType::String),
        required: false,
        hint: None,
        reference_kind: ReferenceKind::Unsupported,
    },
];

let typedef = TypeDef::ArrayOf(Box::new(TypeDef::ObjectOf { fields }));

// Better: use the builder (see Object Fields chapter)
let (pending, fields) = builder.array_of_objects("columns", true, None);
<span class="boring">}</span></code></pre>
<h2 id="objectof"><a class="header" href="#objectof">ObjectOf</a></h2>
<p><code>ObjectOf</code> represents a structured object with named fields. Each field has its own <code>TypeDef</code> and metadata.</p>
<h3 id="usage-3"><a class="header" href="#usage-3">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TypeDef::ObjectOf {
    fields: vec![
        FieldSpec { name: "name", ty: TypeDef::Scalar(ScalarType::String), ... },
        FieldSpec { name: "value", ty: TypeDef::Scalar(ScalarType::Number), ... },
    ]
}
<span class="boring">}</span></code></pre>
<h3 id="when-to-use-3"><a class="header" href="#when-to-use-3">When to Use</a></h3>
<p>Use <code>ObjectOf</code> primarily inside <code>ArrayOf</code>:</p>
<ul>
<li><code>ArrayOf(ObjectOf { ... })</code> for lists of structured items</li>
<li>Rarely used standalone</li>
</ul>
<h3 id="the-fieldspec-structure"><a class="header" href="#the-fieldspec-structure">The FieldSpec Structure</a></h3>
<p>Each field in an <code>ObjectOf</code> is defined by <code>FieldSpec</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FieldSpec&lt;T: Into&lt;String&gt;&gt; {
    pub name: T,
    pub ty: TypeDef&lt;T&gt;,
    pub required: bool,
    pub hint: Option&lt;T&gt;,
    pub reference_kind: ReferenceKind,
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td>Field identifier (must pass NamePolicy)</td></tr>
<tr><td><code>ty</code></td><td>The type of this field</td></tr>
<tr><td><code>required</code></td><td>Whether the field must be present</td></tr>
<tr><td><code>hint</code></td><td>Human-readable description</td></tr>
<tr><td><code>reference_kind</code></td><td>How to evaluate this field (see <a href="#reference-kinds">Reference Kinds</a>)</td></tr>
</tbody>
</table>
</div>
<h2 id="type-nesting"><a class="header" href="#type-nesting">Type Nesting</a></h2>
<p>Types can be nested to create complex structures:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Array of arrays of strings (rarely needed)
TypeDef::ArrayOf(Box::new(
    TypeDef::ArrayOf(Box::new(
        TypeDef::Scalar(ScalarType::String)
    ))
))

// Array of objects containing arrays
let inner_fields = vec![
    FieldSpec {
        name: "tags",
        ty: TypeDef::ArrayOf(Box::new(TypeDef::Scalar(ScalarType::String))),
        required: false,
        hint: None,
        reference_kind: ReferenceKind::Unsupported,
    },
];
TypeDef::ArrayOf(Box::new(TypeDef::ObjectOf { fields: inner_fields }))
<span class="boring">}</span></code></pre>
<h2 id="type-conversion"><a class="header" href="#type-conversion">Type Conversion</a></h2>
<p><code>TypeDef&lt;&amp;'static str&gt;</code> can be converted to <code>TypeDef&lt;String&gt;</code> using <code>Into</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let static_type: TypeDef&lt;&amp;'static str&gt; = TypeDef::Scalar(ScalarType::String);
let owned_type: TypeDef&lt;String&gt; = static_type.into();
<span class="boring">}</span></code></pre>
<p>This conversion is handled automatically by the builder when constructing <code>CommandSpec</code>.</p>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="configuration-attribute"><a class="header" href="#configuration-attribute">Configuration Attribute</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AttributeSpecBuilder::new("config", TypeDef::Scalar(ScalarType::Object))
    .required()
    .hint("JSON configuration object")
    .build()
<span class="boring">}</span></code></pre>
<h3 id="store-path-reference"><a class="header" href="#store-path-reference">Store Path Reference</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AttributeSpecBuilder::new("source", TypeDef::Scalar(ScalarType::String))
    .required()
    .reference(ReferenceKind::StorePath)
    .hint("Path to source data in store")
    .build()
<span class="boring">}</span></code></pre>
<h3 id="named-transforms"><a class="header" href="#named-transforms">Named Transforms</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (pending, fields) = builder.array_of_objects("transforms", true, None);

let (fields, name_ref) = fields.add_literal(
    "name",
    TypeDef::Scalar(ScalarType::String),
    true,
    None
);

let fields = fields.add_template(
    "expr",
    TypeDef::Scalar(ScalarType::String),
    true,
    None,
    ReferenceKind::RuntimeTeraTemplate
);
<span class="boring">}</span></code></pre>
<h2 id="what-happens-if-you-get-it-wrong"><a class="header" href="#what-happens-if-you-get-it-wrong">What Happens If You Get It Wrong</a></h2>
<h3 id="wrong-type-at-runtime"><a class="header" href="#wrong-type-at-runtime">Wrong Type at Runtime</a></h3>
<p>If a pipeline provides data that does not match the expected type, validation fails:</p>
<pre><code class="language-yaml"># Spec expects: TypeDef::Scalar(ScalarType::Number)
my_command:
  count: "not a number"  # Error: expected number, got string
</code></pre>
<h3 id="invalid-derived-result-structure"><a class="header" href="#invalid-derived-result-structure">Invalid Derived Result Structure</a></h3>
<p>If you try to create a derived result from an attribute that is not <code>ArrayOf(ObjectOf)</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This will panic at build time:
// "Derived result attribute 'source' must be ArrayOf(ObjectOf)"
builder
    .attribute(
        AttributeSpecBuilder::new("source", TypeDef::Scalar(ScalarType::String))
            .build()
    )
    .derived_result("source", some_ref, None, ResultKind::Data)
    .build();
<span class="boring">}</span></code></pre>
<p>The spec system catches this error when <code>build()</code> is called, before any pipeline execution.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="reference-kinds"><a class="header" href="#reference-kinds">Reference Kinds</a></h1>
<p>The <code>ReferenceKind</code> enum tells the Panopticon engine how to interpret and evaluate a field’s value. This is critical for dependency tracking, template rendering, and data flow.</p>
<h2 id="the-referencekind-enum"><a class="header" href="#the-referencekind-enum">The ReferenceKind Enum</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Hash, Eq, Default)]
pub enum ReferenceKind {
    StaticTeraTemplate,   // Tera template evaluated before command runs
    RuntimeTeraTemplate,  // Tera template evaluated during execution
    StorePath,            // Direct reference to data in the store
    #[default]
    Unsupported,          // Literal value, no evaluation needed
}
<span class="boring">}</span></code></pre>
<h2 id="unsupported-default"><a class="header" href="#unsupported-default">Unsupported (Default)</a></h2>
<p><code>Unsupported</code> means the field contains a literal value that does not need any evaluation or interpretation. The value is used exactly as provided.</p>
<h3 id="when-to-use-4"><a class="header" href="#when-to-use-4">When to Use</a></h3>
<ul>
<li>String identifiers (names, labels)</li>
<li>Boolean flags</li>
<li>Numeric constants</li>
<li>Any value that should not be interpreted as a template or reference</li>
</ul>
<h3 id="characteristics-1"><a class="header" href="#characteristics-1">Characteristics</a></h3>
<ul>
<li>No template rendering</li>
<li>No dependency tracking</li>
<li>Value is passed through unchanged</li>
<li><strong>Only <code>Unsupported</code> fields can produce <code>LiteralFieldRef</code></strong></li>
</ul>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A simple name field - no template processing
let (fields, name_ref) = fields.add_literal(
    "output_name",
    TypeDef::Scalar(ScalarType::String),
    true,
    Some("Name for the output (literal string)")
);
// Note: add_literal() implies ReferenceKind::Unsupported
<span class="boring">}</span></code></pre>
<h2 id="staticteratemplate"><a class="header" href="#staticteratemplate">StaticTeraTemplate</a></h2>
<p><code>StaticTeraTemplate</code> marks a field whose value is a <a href="https://keats.github.io/tera/">Tera template</a> that will be evaluated <strong>before</strong> the command executes. The template has access to the current namespace context.</p>
<h3 id="when-to-use-1-1"><a class="header" href="#when-to-use-1-1">When to Use</a></h3>
<ul>
<li>Configuration values that need variable substitution</li>
<li>Paths that incorporate variables</li>
<li>Strings that should be computed once at command start</li>
</ul>
<h3 id="characteristics-1-1"><a class="header" href="#characteristics-1-1">Characteristics</a></h3>
<ul>
<li>Evaluated during command initialization</li>
<li>Has access to namespace variables</li>
<li>Result is cached for the command’s lifetime</li>
<li>Dependencies are resolved statically</li>
</ul>
<h3 id="example-1-1"><a class="header" href="#example-1-1">Example</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fields = fields.add_template(
    "output_path",
    TypeDef::Scalar(ScalarType::String),
    true,
    Some("Path with variable substitution: {{ base_path }}/{{ name }}.csv"),
    ReferenceKind::StaticTeraTemplate
);
<span class="boring">}</span></code></pre>
<h3 id="template-syntax"><a class="header" href="#template-syntax">Template Syntax</a></h3>
<pre><code class="language-yaml">my_command:
  output_path: "{{ output_dir }}/report_{{ date }}.json"
</code></pre>
<p>The variables <code>output_dir</code> and <code>date</code> are resolved from the namespace context before execution.</p>
<h2 id="runtimeteratemplate"><a class="header" href="#runtimeteratemplate">RuntimeTeraTemplate</a></h2>
<p><code>RuntimeTeraTemplate</code> marks a field whose value is a Tera template evaluated <strong>during</strong> command execution, potentially multiple times. This is used for expressions that depend on row-level data.</p>
<h3 id="when-to-use-2-1"><a class="header" href="#when-to-use-2-1">When to Use</a></h3>
<ul>
<li>Computed fields based on input data</li>
<li>Row-level transformations</li>
<li>Conditional logic that depends on values from each record</li>
</ul>
<h3 id="characteristics-2"><a class="header" href="#characteristics-2">Characteristics</a></h3>
<ul>
<li>Evaluated during iteration over data</li>
<li>Has access to current row values (typically as <code>item</code>)</li>
<li>May be evaluated many times (once per row)</li>
<li>Cannot be used for derived result names (dynamic evaluation makes names unpredictable)</li>
</ul>
<h3 id="example-2-1"><a class="header" href="#example-2-1">Example</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fields = fields.add_template(
    "expression",
    TypeDef::Scalar(ScalarType::String),
    true,
    Some("Tera expression evaluated for each row"),
    ReferenceKind::RuntimeTeraTemplate
);
<span class="boring">}</span></code></pre>
<h3 id="template-syntax-1"><a class="header" href="#template-syntax-1">Template Syntax</a></h3>
<pre><code class="language-yaml">transform:
  columns:
    - name: "full_name"
      expression: "{{ item.first_name }} {{ item.last_name }}"
    - name: "is_adult"
      expression: "{% if item.age &gt;= 18 %}true{% else %}false{% endif %}"
</code></pre>
<p>The <code>item</code> variable contains the current row during iteration.</p>
<h2 id="storepath"><a class="header" href="#storepath">StorePath</a></h2>
<p><code>StorePath</code> marks a field whose value is a reference to data in the Panopticon store. The engine uses this to track dependencies between commands.</p>
<h3 id="when-to-use-3-1"><a class="header" href="#when-to-use-3-1">When to Use</a></h3>
<ul>
<li>Input data references</li>
<li>References to other command outputs</li>
<li>Any field that points to stored data</li>
</ul>
<h3 id="characteristics-3"><a class="header" href="#characteristics-3">Characteristics</a></h3>
<ul>
<li>Value is interpreted as a store path (e.g., <code>namespace.command.result</code>)</li>
<li>Engine tracks this as a dependency</li>
<li>Data is loaded from the store when accessed</li>
<li>Supports both scalar and tabular data</li>
</ul>
<h3 id="example-3-1"><a class="header" href="#example-3-1">Example</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AttributeSpecBuilder::new("source", TypeDef::Scalar(ScalarType::String))
    .required()
    .reference(ReferenceKind::StorePath)
    .hint("Store path to input data")
    .build()

// Or for tabular references:
AttributeSpecBuilder::new("data", TypeDef::Tabular)
    .required()
    .reference(ReferenceKind::StorePath)
    .hint("Tabular data from another command")
    .build()
<span class="boring">}</span></code></pre>
<h3 id="path-syntax"><a class="header" href="#path-syntax">Path Syntax</a></h3>
<pre><code class="language-yaml">my_command:
  source: "other_namespace.load_data.rows"
</code></pre>
<p>This creates a dependency: <code>my_command</code> depends on <code>other_namespace.load_data.rows</code>.</p>
<h2 id="reference-kind-and-literalfieldref"><a class="header" href="#reference-kind-and-literalfieldref">Reference Kind and LiteralFieldRef</a></h2>
<p>A critical interaction exists between <code>ReferenceKind</code> and the <code>LiteralFieldRef</code> mechanism:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ReferenceKind</th><th>Can produce LiteralFieldRef?</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>Unsupported</code></td><td>Yes</td><td>Value is known at definition time</td></tr>
<tr><td><code>StaticTeraTemplate</code></td><td>No</td><td>Value depends on namespace variables</td></tr>
<tr><td><code>RuntimeTeraTemplate</code></td><td>No</td><td>Value depends on row data</td></tr>
<tr><td><code>StorePath</code></td><td>No</td><td>Value is a reference, not a name</td></tr>
</tbody>
</table>
</div>
<p>This is enforced by the <code>ObjectFields</code> builder:</p>
<ul>
<li><code>add_literal()</code> forces <code>ReferenceKind::Unsupported</code> and returns a <code>LiteralFieldRef</code></li>
<li><code>add_template()</code> accepts any <code>ReferenceKind</code> but does <strong>not</strong> return a <code>LiteralFieldRef</code></li>
</ul>
<h2 id="choosing-the-right-referencekind"><a class="header" href="#choosing-the-right-referencekind">Choosing the Right ReferenceKind</a></h2>
<p>Use this decision tree:</p>
<pre><code>Is the value a reference to stored data?
    Yes -&gt; StorePath
    No  -&gt; Is the value a Tera template?
               Yes -&gt; Does it need row-level data?
                          Yes -&gt; RuntimeTeraTemplate
                          No  -&gt; StaticTeraTemplate
               No  -&gt; Unsupported
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="mixed-fields-in-one-object"><a class="header" href="#mixed-fields-in-one-object">Mixed Fields in One Object</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (pending, fields) = builder.array_of_objects("columns", true, None);

// Literal name - can be used for derived results
let (fields, name_ref) = fields.add_literal(
    "name",
    TypeDef::Scalar(ScalarType::String),
    true,
    Some("Output column name")
);

// Static template - evaluated once
let fields = fields.add_template(
    "source_column",
    TypeDef::Scalar(ScalarType::String),
    true,
    Some("Source column (supports {{ variables }})"),
    ReferenceKind::StaticTeraTemplate
);

// Runtime template - evaluated per row
let fields = fields.add_template(
    "transform",
    TypeDef::Scalar(ScalarType::String),
    false,
    Some("Row transformation: {{ item.value * 2 }}"),
    ReferenceKind::RuntimeTeraTemplate
);

pending
    .finalise_attribute(fields)
    .derived_result("columns", name_ref, None, ResultKind::Data)
    .build()
<span class="boring">}</span></code></pre>
<h3 id="store-path-with-dependency"><a class="header" href="#store-path-with-dependency">Store Path with Dependency</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>CommandSpecBuilder::new()
    .attribute(
        AttributeSpecBuilder::new("input", TypeDef::Tabular)
            .required()
            .reference(ReferenceKind::StorePath)
            .hint("Input data from store")
            .build()
    )
    .attribute(
        AttributeSpecBuilder::new("format", TypeDef::Scalar(ScalarType::String))
            // No .reference() call means Unsupported (default)
            .default_value(ScalarValue::String("json".to_string()))
            .build()
    )
    .fixed_result("output", TypeDef::Tabular, None, ResultKind::Data)
    .build()
<span class="boring">}</span></code></pre>
<h2 id="what-happens-if-you-get-it-wrong-1"><a class="header" href="#what-happens-if-you-get-it-wrong-1">What Happens If You Get It Wrong</a></h2>
<h3 id="wrong-referencekind-for-templates"><a class="header" href="#wrong-referencekind-for-templates">Wrong ReferenceKind for Templates</a></h3>
<p>If you mark a template field as <code>Unsupported</code>, the template syntax will not be evaluated:</p>
<pre><code class="language-yaml"># Field has ReferenceKind::Unsupported but contains template syntax
my_command:
  path: "{{ base }}/output.csv"  # Literal string, NOT evaluated!
</code></pre>
<p>The value will be the literal string <code>"{{ base }}/output.csv"</code>, not the substituted path.</p>
<h3 id="wrong-referencekind-for-store-paths"><a class="header" href="#wrong-referencekind-for-store-paths">Wrong ReferenceKind for Store Paths</a></h3>
<p>If you mark a store path as <code>Unsupported</code>, dependency tracking will fail:</p>
<pre><code class="language-yaml"># Field has ReferenceKind::Unsupported but contains a store path
my_command:
  source: "other.command.data"  # Treated as literal string, not a reference
</code></pre>
<p>The engine will not recognize this as a dependency, potentially causing execution order issues.</p>
<h3 id="using-template-fields-for-derived-results"><a class="header" href="#using-template-fields-for-derived-results">Using Template Fields for Derived Results</a></h3>
<p>This is prevented at compile time. If you try, you will find there is no <code>LiteralFieldRef</code> to pass:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// add_template returns just ObjectFields, not (ObjectFields, LiteralFieldRef)
let fields = fields.add_template("name", ..., ReferenceKind::StaticTeraTemplate);

// No name_ref exists - compiler error if you try to use it
// builder.derived_result("attr", name_ref, ...) // Won't compile!
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="object-fields"><a class="header" href="#object-fields">Object Fields</a></h1>
<p>The <code>ObjectFields</code> builder provides a type-safe way to construct fields for <code>ObjectOf</code> type definitions. Its key feature is the distinction between <strong>literal</strong> and <strong>template</strong> fields, which enables compile-time safety for derived results.</p>
<h2 id="the-objectfields-builder"><a class="header" href="#the-objectfields-builder">The ObjectFields Builder</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ObjectFields&lt;T: Into&lt;String&gt;&gt; {
    fields: Vec&lt;FieldSpec&lt;T&gt;&gt;,
}
<span class="boring">}</span></code></pre>
<p><code>ObjectFields</code> is obtained from <code>CommandSpecBuilder::array_of_objects()</code> and provides two methods for adding fields:</p>
<ul>
<li><code>add_literal()</code> - Returns <code>(Self, LiteralFieldRef&lt;T&gt;)</code></li>
<li><code>add_template()</code> - Returns <code>Self</code></li>
</ul>
<p>This asymmetry is intentional and forms the foundation of compile-time safety.</p>
<h2 id="creating-objectfields"><a class="header" href="#creating-objectfields">Creating ObjectFields</a></h2>
<p>You do not create <code>ObjectFields</code> directly. Instead, use <code>CommandSpecBuilder::array_of_objects()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let builder = CommandSpecBuilder::new();

// array_of_objects returns (PendingAttribute, ObjectFields)
let (pending, fields) = builder.array_of_objects(
    "items",      // Attribute name
    true,         // Required
    Some("List of items to process")  // Hint
);

// Now use 'fields' to add field specifications
// Later use 'pending' to finalize and continue building
<span class="boring">}</span></code></pre>
<h2 id="add_literal-literal-fields"><a class="header" href="#add_literal-literal-fields">add_literal: Literal Fields</a></h2>
<p><code>add_literal()</code> creates a field with <code>ReferenceKind::Unsupported</code> and returns a <code>LiteralFieldRef</code> handle.</p>
<h3 id="signature"><a class="header" href="#signature">Signature</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_literal(
    self,
    name: T,
    ty: TypeDef&lt;T&gt;,
    required: bool,
    hint: Option&lt;T&gt;,
) -&gt; (Self, LiteralFieldRef&lt;T&gt;)
<span class="boring">}</span></code></pre>
<h3 id="usage-4"><a class="header" href="#usage-4">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (fields, name_ref) = fields.add_literal(
    "name",
    TypeDef::Scalar(ScalarType::String),
    true,
    Some("Item name - will be used as result key")
);
<span class="boring">}</span></code></pre>
<h3 id="return-value-1"><a class="header" href="#return-value-1">Return Value</a></h3>
<p>The tuple <code>(Self, LiteralFieldRef&lt;T&gt;)</code> gives you:</p>
<ol>
<li>The updated <code>ObjectFields</code> builder to continue adding fields</li>
<li>A <code>LiteralFieldRef</code> proving this field contains literal data</li>
</ol>
<h3 id="when-to-use-5"><a class="header" href="#when-to-use-5">When to Use</a></h3>
<p>Use <code>add_literal()</code> when:</p>
<ul>
<li>The field contains a fixed value (not a template)</li>
<li>The field might be used as a derived result name</li>
<li>The field should not undergo any template processing</li>
</ul>
<h2 id="add_template-template-fields"><a class="header" href="#add_template-template-fields">add_template: Template Fields</a></h2>
<p><code>add_template()</code> creates a field with a specified <code>ReferenceKind</code> and does <strong>not</strong> return a <code>LiteralFieldRef</code>.</p>
<h3 id="signature-1"><a class="header" href="#signature-1">Signature</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_template(
    self,
    name: T,
    ty: TypeDef&lt;T&gt;,
    required: bool,
    hint: Option&lt;T&gt;,
    kind: ReferenceKind,
) -&gt; Self
<span class="boring">}</span></code></pre>
<h3 id="usage-1-1"><a class="header" href="#usage-1-1">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fields = fields.add_template(
    "expression",
    TypeDef::Scalar(ScalarType::String),
    true,
    Some("Tera expression: {{ item.value * 2 }}"),
    ReferenceKind::RuntimeTeraTemplate
);
<span class="boring">}</span></code></pre>
<h3 id="return-value-1-1"><a class="header" href="#return-value-1-1">Return Value</a></h3>
<p>Returns only <code>Self</code> - no <code>LiteralFieldRef</code> is produced.</p>
<h3 id="when-to-use-1-2"><a class="header" href="#when-to-use-1-2">When to Use</a></h3>
<p>Use <code>add_template()</code> when:</p>
<ul>
<li>The field contains a Tera template (static or runtime)</li>
<li>The field is a store path reference</li>
<li>The field should never be used as a derived result name</li>
</ul>
<h2 id="the-critical-difference"><a class="header" href="#the-critical-difference">The Critical Difference</a></h2>
<p>The return type difference is the <strong>entire point</strong> of this design:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Returns</th><th>LiteralFieldRef?</th></tr>
</thead>
<tbody>
<tr><td><code>add_literal()</code></td><td><code>(Self, LiteralFieldRef&lt;T&gt;)</code></td><td>Yes</td></tr>
<tr><td><code>add_template()</code></td><td><code>Self</code></td><td>No</td></tr>
</tbody>
</table>
</div>
<p>Since <code>derived_result()</code> requires a <code>LiteralFieldRef</code>, and <code>add_template()</code> does not produce one, <strong>the compiler prevents template fields from being used as derived result names</strong>.</p>
<h2 id="chaining-fields"><a class="header" href="#chaining-fields">Chaining Fields</a></h2>
<p>Both methods consume and return <code>Self</code>, enabling fluent chaining:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (pending, fields) = builder.array_of_objects("columns", true, None);

// Chain literal and template fields
let (fields, name_ref) = fields.add_literal(
    "name",
    TypeDef::Scalar(ScalarType::String),
    true,
    None
);

let (fields, _alias_ref) = fields.add_literal(
    "alias",
    TypeDef::Scalar(ScalarType::String),
    false,
    None
);

let fields = fields.add_template(
    "source",
    TypeDef::Scalar(ScalarType::String),
    true,
    None,
    ReferenceKind::StaticTeraTemplate
);

let fields = fields.add_template(
    "transform",
    TypeDef::Scalar(ScalarType::String),
    false,
    None,
    ReferenceKind::RuntimeTeraTemplate
);
<span class="boring">}</span></code></pre>
<p>Note: You can collect multiple <code>LiteralFieldRef</code> handles, but you only need one for each derived result.</p>
<h2 id="building-and-validation"><a class="header" href="#building-and-validation">Building and Validation</a></h2>
<p>Call <code>build()</code> to finalize the fields:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let field_vec: Vec&lt;FieldSpec&lt;T&gt;&gt; = fields.build();
<span class="boring">}</span></code></pre>
<p><code>build()</code> validates all field names against <code>DEFAULT_NAME_POLICY</code>:</p>
<ul>
<li>Reserved names (<code>item</code>, <code>index</code>) are rejected</li>
<li>Forbidden characters are rejected</li>
</ul>
<h3 id="what-happens-if-validation-fails"><a class="header" href="#what-happens-if-validation-fails">What Happens If Validation Fails</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (fields, _) = fields.add_literal(
    "item",  // Reserved name!
    TypeDef::Scalar(ScalarType::String),
    true,
    None
);

// This panics:
// "NamePolicy violation: field name 'item' is reserved"
fields.build();
<span class="boring">}</span></code></pre>
<h2 id="finalizing-the-attribute"><a class="header" href="#finalizing-the-attribute">Finalizing the Attribute</a></h2>
<p>Use <code>PendingAttribute::finalise_attribute()</code> to complete the attribute and return to the main builder:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (pending, fields) = builder.array_of_objects("transforms", true, None);

let (fields, name_ref) = fields.add_literal(/* ... */);
let fields = fields.add_template(/* ... */);

// Finalize and continue with the main builder
let builder = pending.finalise_attribute(fields);

// Now you can add more attributes, fixed results, or derived results
let (attrs, results) = builder
    .derived_result("transforms", name_ref, None, ResultKind::Data)
    .build();
<span class="boring">}</span></code></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::extend::*;

fn build_spec() -&gt; (Vec&lt;AttributeSpec&lt;&amp;'static str&gt;&gt;, Vec&lt;ResultSpec&lt;&amp;'static str&gt;&gt;) {
    let builder = CommandSpecBuilder::new();

    // Simple scalar attribute
    let builder = builder.attribute(
        AttributeSpecBuilder::new("output_format", TypeDef::Scalar(ScalarType::String))
            .default_value(ScalarValue::String("json".to_string()))
            .build()
    );

    // Array of objects with mixed literal and template fields
    let (pending, fields) = builder.array_of_objects(
        "computations",
        true,
        Some("Named computations to perform")
    );

    // Literal: name will be used for derived results
    let (fields, name_ref) = fields.add_literal(
        "name",
        TypeDef::Scalar(ScalarType::String),
        true,
        Some("Computation name (becomes result key)")
    );

    // Literal: optional description
    let (fields, _desc_ref) = fields.add_literal(
        "description",
        TypeDef::Scalar(ScalarType::String),
        false,
        Some("Human-readable description")
    );

    // Template: the actual computation
    let fields = fields.add_template(
        "formula",
        TypeDef::Scalar(ScalarType::String),
        true,
        Some("Tera formula: {{ item.a + item.b }}"),
        ReferenceKind::RuntimeTeraTemplate
    );

    // Template: optional filter condition
    let fields = fields.add_template(
        "condition",
        TypeDef::Scalar(ScalarType::String),
        false,
        Some("Filter: {% if item.valid %}"),
        ReferenceKind::RuntimeTeraTemplate
    );

    // Finalize and build
    pending
        .finalise_attribute(fields)
        .fixed_result(
            "summary",
            TypeDef::Scalar(ScalarType::Object),
            Some("Execution summary"),
            ResultKind::Meta
        )
        .derived_result(
            "computations",
            name_ref,
            None,
            ResultKind::Data
        )
        .build()
}
<span class="boring">}</span></code></pre>
<h2 id="why-not-just-use-fieldspec-directly"><a class="header" href="#why-not-just-use-fieldspec-directly">Why Not Just Use FieldSpec Directly?</a></h2>
<p>You could construct <code>FieldSpec</code> and <code>TypeDef::ObjectOf</code> directly:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This works but provides no compile-time safety
let fields = vec![
    FieldSpec {
        name: "name",
        ty: TypeDef::Scalar(ScalarType::String),
        required: true,
        hint: None,
        reference_kind: ReferenceKind::Unsupported,
    },
    FieldSpec {
        name: "value",
        ty: TypeDef::Scalar(ScalarType::String),
        required: true,
        hint: None,
        reference_kind: ReferenceKind::RuntimeTeraTemplate,
    },
];

let typedef = TypeDef::ArrayOf(Box::new(TypeDef::ObjectOf { fields }));
<span class="boring">}</span></code></pre>
<p>The problem: you have no <code>LiteralFieldRef</code>, so you cannot use <code>derived_result()</code>. The <code>ObjectFields</code> builder is the <strong>only</strong> way to obtain a <code>LiteralFieldRef</code>, which is the <strong>only</strong> way to use derived results safely.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="literalfieldref-compile-time-safety"><a class="header" href="#literalfieldref-compile-time-safety">LiteralFieldRef: Compile-Time Safety</a></h1>
<p><code>LiteralFieldRef</code> is an opaque handle that proves a field has <code>ReferenceKind::Unsupported</code> (i.e., contains literal data). This is the key mechanism that enables compile-time safety for derived results.</p>
<h2 id="the-problem-literalfieldref-solves"><a class="header" href="#the-problem-literalfieldref-solves">The Problem LiteralFieldRef Solves</a></h2>
<p>Derived results in Panopticon use field values as result names. Consider:</p>
<pre><code class="language-yaml">my_command:
  columns:
    - name: "total"
      expression: "{{ item.a + item.b }}"
    - name: "average"
      expression: "{{ item.sum / item.count }}"
</code></pre>
<p>This produces results named <code>"total"</code> and <code>"average"</code>. The <code>name</code> field values become keys in the output.</p>
<p>But what if <code>name</code> were a template?</p>
<pre><code class="language-yaml">my_command:
  columns:
    - name: "{{ item.column_name }}"  # Template!
      expression: "{{ item.value }}"
</code></pre>
<p>The result names would depend on <strong>runtime data</strong>, making it impossible to know them at pipeline definition time. This breaks dependency tracking and type safety.</p>
<h2 id="the-solution-proof-of-literalness"><a class="header" href="#the-solution-proof-of-literalness">The Solution: Proof of Literalness</a></h2>
<p><code>LiteralFieldRef</code> is a compile-time proof that a field cannot contain templates. The type system enforces this:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Hash, Eq)]
pub struct LiteralFieldRef&lt;T: Into&lt;String&gt;&gt; {
    name: T,  // Private field!
}
<span class="boring">}</span></code></pre>
<p>The <code>name</code> field is <strong>private</strong>. You cannot construct a <code>LiteralFieldRef</code> directly. The only way to obtain one is through <code>ObjectFields::add_literal()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Into&lt;String&gt; + Clone&gt; ObjectFields&lt;T&gt; {
    pub fn add_literal(
        mut self,
        name: T,
        ty: TypeDef&lt;T&gt;,
        required: bool,
        hint: Option&lt;T&gt;,
    ) -&gt; (Self, LiteralFieldRef&lt;T&gt;) {
        // Creates field with ReferenceKind::Unsupported
        // Returns the proof handle
        let handle = LiteralFieldRef { name: name.clone() };
        self.fields.push(FieldSpec {
            name,
            ty,
            required,
            hint,
            reference_kind: ReferenceKind::Unsupported,  // Always literal
        });
        (self, handle)
    }
}
<span class="boring">}</span></code></pre>
<h2 id="how-it-prevents-errors"><a class="header" href="#how-it-prevents-errors">How It Prevents Errors</a></h2>
<p><code>derived_result()</code> requires a <code>LiteralFieldRef</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn derived_result(
    mut self,
    attribute: T,
    name_field: LiteralFieldRef&lt;T&gt;,  // Must have this proof
    ty: Option&lt;TypeDef&lt;T&gt;&gt;,
    kind: ResultKind,
) -&gt; Self
<span class="boring">}</span></code></pre>
<p>Since <code>add_template()</code> does not return a <code>LiteralFieldRef</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_template(
    self,
    name: T,
    ty: TypeDef&lt;T&gt;,
    required: bool,
    hint: Option&lt;T&gt;,
    kind: ReferenceKind,
) -&gt; Self  // No LiteralFieldRef!
<span class="boring">}</span></code></pre>
<p>…you <strong>cannot</strong> pass a template field to <code>derived_result()</code>. The compiler will not allow it because there is no <code>LiteralFieldRef</code> for that field.</p>
<h2 id="demonstration"><a class="header" href="#demonstration">Demonstration</a></h2>
<h3 id="valid-usage"><a class="header" href="#valid-usage">Valid Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (pending, fields) = CommandSpecBuilder::new()
    .array_of_objects("items", true, None);

// add_literal returns (ObjectFields, LiteralFieldRef)
let (fields, name_ref) = fields.add_literal(
    "name",
    TypeDef::Scalar(ScalarType::String),
    true,
    None
);

// name_ref proves "name" is literal - can use it for derived_result
let (attrs, results) = pending
    .finalise_attribute(fields)
    .derived_result("items", name_ref, None, ResultKind::Data)
    .build();
<span class="boring">}</span></code></pre>
<h3 id="attempting-invalid-usage"><a class="header" href="#attempting-invalid-usage">Attempting Invalid Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (pending, fields) = CommandSpecBuilder::new()
    .array_of_objects("items", true, None);

// add_template returns just ObjectFields
let fields = fields.add_template(
    "computed_name",
    TypeDef::Scalar(ScalarType::String),
    true,
    None,
    ReferenceKind::RuntimeTeraTemplate
);

// There is no LiteralFieldRef for "computed_name"
// This will NOT compile:
//
// let (attrs, results) = pending
//     .finalise_attribute(fields)
//     .derived_result("items", ???, None, ResultKind::Data)
//                              ^^^
//                     No LiteralFieldRef exists for the template field!
//     .build();
<span class="boring">}</span></code></pre>
<p>The error is caught at compile time, not runtime.</p>
<h2 id="the-type-level-guarantee"><a class="header" href="#the-type-level-guarantee">The Type-Level Guarantee</a></h2>
<p>This pattern provides a type-level guarantee:</p>
<ol>
<li><code>LiteralFieldRef&lt;T&gt;</code> can only be created inside the <code>spec</code> module (private constructor)</li>
<li>The only public way to obtain one is <code>ObjectFields::add_literal()</code></li>
<li><code>add_literal()</code> always sets <code>ReferenceKind::Unsupported</code></li>
<li>Therefore, any <code>LiteralFieldRef</code> you have <strong>proves</strong> the field is literal</li>
</ol>
<p>This is not a convention or documentation - it is enforced by Rust’s type system and module privacy.</p>
<h2 id="accessing-the-name"><a class="header" href="#accessing-the-name">Accessing the Name</a></h2>
<p>You can read the field name from a <code>LiteralFieldRef</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Into&lt;String&gt; + Clone&gt; LiteralFieldRef&lt;T&gt; {
    pub fn name(&amp;self) -&gt; &amp;T {
        &amp;self.name
    }
}
<span class="boring">}</span></code></pre>
<p>This is used by <code>build()</code> to verify that the referenced field actually exists in the attribute.</p>
<h2 id="build-time-validation"><a class="header" href="#build-time-validation">Build-Time Validation</a></h2>
<p>While compile-time safety prevents using template fields for derived results, build-time validation catches other errors:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (pending, fields) = CommandSpecBuilder::new()
    .array_of_objects("things", true, None);

let (fields, name_ref) = fields.add_literal("name", ...);

pending
    .finalise_attribute(fields)
    // Wrong attribute name - "items" doesn't exist, we have "things"
    .derived_result("items", name_ref, None, ResultKind::Data)
    .build();  // Panics: "Derived result references unknown attribute 'items'"
<span class="boring">}</span></code></pre>
<p>The builder verifies:</p>
<ol>
<li>The referenced attribute exists</li>
<li>The attribute is <code>ArrayOf(ObjectOf { ... })</code></li>
<li>The <code>LiteralFieldRef</code> name matches a field in those objects</li>
</ol>
<h2 id="why-this-pattern-matters"><a class="header" href="#why-this-pattern-matters">Why This Pattern Matters</a></h2>
<p>Without <code>LiteralFieldRef</code>, you could make this mistake:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Hypothetical unsafe API (not how Panopticon works)
builder.derived_result("items", "template_field", ...)
<span class="boring">}</span></code></pre>
<p>This would compile but fail at runtime when template evaluation produces unpredictable names.</p>
<p>With <code>LiteralFieldRef</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Safe API (actual Panopticon)
builder.derived_result("items", name_ref, ...)
//                              ^^^^^^^^
//                     Must be a LiteralFieldRef
//                     Can only come from add_literal()
//                     Guarantees field is literal
<span class="boring">}</span></code></pre>
<p>The error is impossible to make because the type system does not allow it.</p>
<h2 id="multiple-literalfieldrefs"><a class="header" href="#multiple-literalfieldrefs">Multiple LiteralFieldRefs</a></h2>
<p>You can have multiple literal fields and thus multiple <code>LiteralFieldRef</code> handles:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (fields, name_ref) = fields.add_literal("name", ...);
let (fields, key_ref) = fields.add_literal("key", ...);
let (fields, id_ref) = fields.add_literal("id", ...);
<span class="boring">}</span></code></pre>
<p>You choose which one to use for <code>derived_result()</code>. Each handle proves its respective field is literal.</p>
<h2 id="conversion"><a class="header" href="#conversion">Conversion</a></h2>
<p><code>LiteralFieldRef&lt;&amp;'static str&gt;</code> can convert to <code>LiteralFieldRef&lt;String&gt;</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;LiteralFieldRef&lt;&amp;'static str&gt;&gt; for LiteralFieldRef&lt;String&gt; {
    fn from(r: LiteralFieldRef&lt;&amp;'static str&gt;) -&gt; Self {
        LiteralFieldRef {
            name: r.name.into(),
        }
    }
}
<span class="boring">}</span></code></pre>
<p>This happens automatically when building <code>CommandSpec</code> from static specs.</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p><code>LiteralFieldRef</code> is an example of “making invalid states unrepresentable” through the type system:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Want to do</th><th>Required</th><th>How to get it</th></tr>
</thead>
<tbody>
<tr><td>Use derived results</td><td><code>LiteralFieldRef</code></td><td><code>add_literal()</code></td></tr>
<tr><td>Use template fields</td><td>Just <code>ObjectFields</code></td><td><code>add_template()</code></td></tr>
</tbody>
</table>
</div>
<p>The asymmetry is intentional: derived result names must be predictable, so only literal fields qualify. The type system enforces this at compile time.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="name-policy"><a class="header" href="#name-policy">Name Policy</a></h1>
<p>The <code>NamePolicy</code> struct enforces naming conventions across the spec system. It prevents conflicts with reserved identifiers and ensures names are safe for use in templates and store paths.</p>
<h2 id="the-namepolicy-struct"><a class="header" href="#the-namepolicy-struct">The NamePolicy Struct</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NamePolicy {
    pub reserved_names: &amp;'static [&amp;'static str],
    forbidden_regex: Regex,
}
<span class="boring">}</span></code></pre>
<p>A <code>NamePolicy</code> defines:</p>
<ol>
<li><strong>Reserved names</strong> - Identifiers that cannot be used (exact match)</li>
<li><strong>Forbidden pattern</strong> - A regex matching characters that are not allowed</li>
</ol>
<h2 id="default-name-policy"><a class="header" href="#default-name-policy">Default Name Policy</a></h2>
<p>Panopticon provides a default policy:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub static DEFAULT_NAME_POLICY: LazyLock&lt;NamePolicy&gt; =
    LazyLock::new(|| NamePolicy::new(&amp;["item", "index"], r"[^a-zA-Z0-9_]"));
<span class="boring">}</span></code></pre>
<p>This policy:</p>
<ul>
<li><strong>Reserves</strong> <code>item</code> and <code>index</code></li>
<li><strong>Forbids</strong> any character that is not alphanumeric or underscore</li>
</ul>
<h2 id="reserved-names"><a class="header" href="#reserved-names">Reserved Names</a></h2>
<h3 id="why-item-and-index"><a class="header" href="#why-item-and-index">Why “item” and “index”?</a></h3>
<p>These names are reserved because they have special meaning in iterative namespaces:</p>
<ul>
<li><code>item</code> - Refers to the current element during iteration</li>
<li><code>index</code> - Refers to the current position (0-based) during iteration</li>
</ul>
<p>Using these as field or attribute names would shadow the built-in meanings, causing confusing behavior.</p>
<h3 id="example-collision"><a class="header" href="#example-collision">Example Collision</a></h3>
<pre><code class="language-yaml"># In iterative context, 'item' refers to current element
transform:
  expression: "{{ item.value * 2 }}"  # item = current row

# If you named a field 'item', confusion ensues
columns:
  - item: "foo"  # Shadows the built-in 'item'!
</code></pre>
<h3 id="violation-message"><a class="header" href="#violation-message">Violation Message</a></h3>
<pre><code>NamePolicy violation: attribute name 'item' is reserved
</code></pre>
<h2 id="forbidden-characters"><a class="header" href="#forbidden-characters">Forbidden Characters</a></h2>
<h3 id="why-restrict-characters"><a class="header" href="#why-restrict-characters">Why Restrict Characters?</a></h3>
<p>Names appear in multiple contexts:</p>
<ol>
<li><strong>Store paths</strong> - <code>namespace.command.result</code> uses dots as separators</li>
<li><strong>Tera templates</strong> - <code>{{ field_name }}</code> requires valid identifiers</li>
<li><strong>YAML keys</strong> - Some characters have special meaning</li>
</ol>
<p>Restricting to <code>[a-zA-Z0-9_]</code> ensures names work everywhere.</p>
<h3 id="what-is-forbidden"><a class="header" href="#what-is-forbidden">What Is Forbidden?</a></h3>
<p>Any character matching <code>[^a-zA-Z0-9_]</code> is forbidden:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Forbidden</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>.</code> (dot)</td><td>Store path separator</td></tr>
<tr><td><code> </code> (space)</td><td>Invalid in most contexts</td></tr>
<tr><td><code>-</code> (hyphen)</td><td>Can be confused with subtraction in templates</td></tr>
<tr><td><code>!@#$%^&amp;*</code></td><td>Special characters in various syntaxes</td></tr>
<tr><td>Unicode</td><td>Potential encoding issues</td></tr>
</tbody>
</table>
</div>
<h3 id="violation-message-1"><a class="header" href="#violation-message-1">Violation Message</a></h3>
<pre><code>NamePolicy violation: field name 'bad.name' contains forbidden characters (pattern: [^a-zA-Z0-9_])
</code></pre>
<h2 id="when-validation-occurs"><a class="header" href="#when-validation-occurs">When Validation Occurs</a></h2>
<p>The <code>DEFAULT_NAME_POLICY</code> is checked at several points:</p>
<h3 id="1-objectfieldsbuild"><a class="header" href="#1-objectfieldsbuild">1. ObjectFields.build()</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Into&lt;String&gt; + Clone&gt; ObjectFields&lt;T&gt; {
    pub fn build(self) -&gt; Vec&lt;FieldSpec&lt;T&gt;&gt; {
        for field in &amp;self.fields {
            DEFAULT_NAME_POLICY.validate(field.name.clone(), "field");
        }
        self.fields
    }
}
<span class="boring">}</span></code></pre>
<h3 id="2-commandspecbuilderbuild"><a class="header" href="#2-commandspecbuilderbuild">2. CommandSpecBuilder.build()</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn build(self) -&gt; (Vec&lt;AttributeSpec&lt;T&gt;&gt;, Vec&lt;ResultSpec&lt;T&gt;&gt;) {
    let policy = &amp;*DEFAULT_NAME_POLICY;

    for attr in &amp;self.attributes {
        policy.validate(attr.name.clone(), "attribute");
    }

    for result in &amp;self.results {
        match result {
            ResultSpec::Field { name, .. } =&gt; {
                policy.validate(name.clone(), "result");
            }
            ResultSpec::DerivedFromSingleAttribute { .. } =&gt; {
                // Derived names come from runtime data, not validated here
            }
        }
    }

    // ... rest of build
}
<span class="boring">}</span></code></pre>
<h2 id="the-validate-method"><a class="header" href="#the-validate-method">The validate() Method</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl NamePolicy {
    pub fn validate(&amp;self, name: impl Into&lt;String&gt;, context: &amp;str) {
        let name = name.into();

        if self.reserved_names.contains(&amp;name.as_str()) {
            panic!(
                "NamePolicy violation: {} name '{}' is reserved",
                context, name
            );
        }

        if self.forbidden_regex.is_match(&amp;name) {
            panic!(
                "NamePolicy violation: {} name '{}' contains forbidden characters (pattern: {})",
                context,
                name,
                self.forbidden_regex.as_str()
            );
        }
    }
}
<span class="boring">}</span></code></pre>
<p>The <code>context</code> parameter produces helpful error messages:</p>
<ul>
<li><code>"NamePolicy violation: attribute name 'item' is reserved"</code></li>
<li><code>"NamePolicy violation: field name 'bad.name' contains forbidden characters"</code></li>
<li><code>"NamePolicy violation: result name 'my field' contains forbidden characters"</code></li>
</ul>
<h2 id="examples-of-valid-names"><a class="header" href="#examples-of-valid-names">Examples of Valid Names</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All of these pass validation
DEFAULT_NAME_POLICY.validate("data", "result");        // OK
DEFAULT_NAME_POLICY.validate("output_path", "field");  // OK
DEFAULT_NAME_POLICY.validate("Column2", "attribute");  // OK
DEFAULT_NAME_POLICY.validate("myValue", "field");      // OK
DEFAULT_NAME_POLICY.validate("X", "attribute");        // OK
DEFAULT_NAME_POLICY.validate("a1b2c3", "field");       // OK
<span class="boring">}</span></code></pre>
<h2 id="examples-of-invalid-names"><a class="header" href="#examples-of-invalid-names">Examples of Invalid Names</a></h2>
<h3 id="reserved-names-1"><a class="header" href="#reserved-names-1">Reserved Names</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Panics: "NamePolicy violation: attribute name 'item' is reserved"
DEFAULT_NAME_POLICY.validate("item", "attribute");

// Panics: "NamePolicy violation: field name 'index' is reserved"
DEFAULT_NAME_POLICY.validate("index", "field");
<span class="boring">}</span></code></pre>
<h3 id="forbidden-characters-1"><a class="header" href="#forbidden-characters-1">Forbidden Characters</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Panics: contains forbidden characters
DEFAULT_NAME_POLICY.validate("my field", "attribute");   // space
DEFAULT_NAME_POLICY.validate("store.path", "result");    // dot
DEFAULT_NAME_POLICY.validate("field-name", "field");     // hyphen
DEFAULT_NAME_POLICY.validate("data!", "attribute");      // exclamation
DEFAULT_NAME_POLICY.validate("value@2", "field");        // at sign
<span class="boring">}</span></code></pre>
<h2 id="catching-violations-at-build-time"><a class="header" href="#catching-violations-at-build-time">Catching Violations at Build Time</a></h2>
<p>Here is how violations manifest in practice:</p>
<h3 id="attribute-name-violation"><a class="header" href="#attribute-name-violation">Attribute Name Violation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = std::panic::catch_unwind(|| {
    CommandSpecBuilder::&lt;&amp;str&gt;::new()
        .attribute(
            AttributeSpecBuilder::new("item", TypeDef::Scalar(ScalarType::String))
                .build()
        )
        .build();
});
// Panics: "NamePolicy violation: attribute name 'item' is reserved"
<span class="boring">}</span></code></pre>
<h3 id="field-name-violation"><a class="header" href="#field-name-violation">Field Name Violation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = std::panic::catch_unwind(|| {
    let (pending, fields) = CommandSpecBuilder::new()
        .array_of_objects("columns", true, None);

    let (fields, _) = fields.add_literal(
        "my.field",  // Contains forbidden '.'
        TypeDef::Scalar(ScalarType::String),
        true,
        None
    );

    pending.finalise_attribute(fields).build();
});
// Panics: "NamePolicy violation: field name 'my.field' contains forbidden characters"
<span class="boring">}</span></code></pre>
<h3 id="result-name-violation"><a class="header" href="#result-name-violation">Result Name Violation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = std::panic::catch_unwind(|| {
    CommandSpecBuilder::&lt;&amp;str&gt;::new()
        .fixed_result(
            "output data",  // Contains forbidden space
            TypeDef::Tabular,
            None,
            ResultKind::Data
        )
        .build();
});
// Panics: "NamePolicy violation: result name 'output data' contains forbidden characters"
<span class="boring">}</span></code></pre>
<h2 id="derived-results-and-name-policy"><a class="header" href="#derived-results-and-name-policy">Derived Results and Name Policy</a></h2>
<p>Derived result names come from runtime data, not from the spec. Therefore, <code>NamePolicy</code> does <strong>not</strong> validate them at build time:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ResultSpec::DerivedFromSingleAttribute { .. } =&gt; {
    // Derived result names come from runtime data, not spec-defined names
}
<span class="boring">}</span></code></pre>
<p>However, the <code>LiteralFieldRef</code> mechanism ensures the names come from a literal field, so they should be predictable strings defined in the pipeline YAML.</p>
<h2 id="custom-name-policy"><a class="header" href="#custom-name-policy">Custom Name Policy</a></h2>
<p>You can create a custom <code>NamePolicy</code> for specialized validation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let strict_policy = NamePolicy::new(
    &amp;["item", "index", "self", "this", "parent"],  // More reserved words
    r"[^a-z_]"  // Only lowercase letters and underscores
);

strict_policy.validate("my_field", "field");  // OK
strict_policy.validate("MyField", "field");   // Panics: uppercase forbidden
strict_policy.validate("self", "attribute");  // Panics: reserved
<span class="boring">}</span></code></pre>
<p>However, the default policy is used throughout the standard builders. Custom policies would require building specs manually.</p>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="do"><a class="header" href="#do">DO</a></h3>
<ul>
<li>Use <code>snake_case</code> for names: <code>output_path</code>, <code>column_name</code>, <code>data_source</code></li>
<li>Keep names descriptive but concise</li>
<li>Use alphabetic characters primarily, numbers sparingly</li>
</ul>
<h3 id="do-not"><a class="header" href="#do-not">DO NOT</a></h3>
<ul>
<li>Use reserved words (<code>item</code>, <code>index</code>)</li>
<li>Include dots (they are path separators)</li>
<li>Include spaces or hyphens</li>
<li>Use special characters</li>
<li>Start names with numbers (valid but unconventional)</li>
</ul>
<h3 id="naming-examples"><a class="header" href="#naming-examples">Naming Examples</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Good</th><th>Bad</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>output_file</code></td><td><code>output.file</code></td><td>Dot is forbidden</td></tr>
<tr><td><code>column_name</code></td><td><code>column-name</code></td><td>Hyphen is forbidden</td></tr>
<tr><td><code>data_source</code></td><td><code>data source</code></td><td>Space is forbidden</td></tr>
<tr><td><code>row_count</code></td><td><code>item</code></td><td>Reserved word</td></tr>
<tr><td><code>position</code></td><td><code>index</code></td><td>Reserved word</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="result-specs"><a class="header" href="#result-specs">Result Specs</a></h1>
<p>The <code>ResultSpec</code> enum defines what outputs a command produces. Results can be <strong>fixed</strong> (known at definition time) or <strong>derived</strong> (names determined by input data).</p>
<h2 id="the-resultspec-enum"><a class="header" href="#the-resultspec-enum">The ResultSpec Enum</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ResultSpec&lt;T: Into&lt;String&gt;&gt; {
    Field {
        name: T,
        ty: TypeDef&lt;T&gt;,
        hint: Option&lt;T&gt;,
        kind: ResultKind,
    },
    DerivedFromSingleAttribute {
        attribute: T,
        name_field: LiteralFieldRef&lt;T&gt;,
        ty: Option&lt;TypeDef&lt;T&gt;&gt;,
        kind: ResultKind,
    },
}
<span class="boring">}</span></code></pre>
<h2 id="resultkind-1"><a class="header" href="#resultkind-1">ResultKind</a></h2>
<p>Every result has a <code>ResultKind</code> indicating its purpose:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ResultKind {
    Data,
    Meta,
}
<span class="boring">}</span></code></pre>
<h3 id="data-results-1"><a class="header" href="#data-results-1">Data Results</a></h3>
<p><code>ResultKind::Data</code> indicates the result contains primary output data:</p>
<ul>
<li>Query results</li>
<li>Transformed datasets</li>
<li>Computed values</li>
</ul>
<p>Data results are typically consumed by downstream commands.</p>
<h3 id="meta-results"><a class="header" href="#meta-results">Meta Results</a></h3>
<p><code>ResultKind::Meta</code> indicates the result contains metadata about execution:</p>
<ul>
<li>Row counts</li>
<li>Execution statistics</li>
<li>Validation summaries</li>
</ul>
<p>Meta results are often used for logging or debugging rather than data flow.</p>
<h2 id="fixed-results-resultspecfield"><a class="header" href="#fixed-results-resultspecfield">Fixed Results (ResultSpec::Field)</a></h2>
<p>Fixed results have names known at command definition time.</p>
<h3 id="structure"><a class="header" href="#structure">Structure</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ResultSpec::Field {
    name: T,           // Result identifier
    ty: TypeDef&lt;T&gt;,    // Type of the result
    hint: Option&lt;T&gt;,   // Human-readable description
    kind: ResultKind,  // Data or Meta
}
<span class="boring">}</span></code></pre>
<h3 id="creating-fixed-results"><a class="header" href="#creating-fixed-results">Creating Fixed Results</a></h3>
<p>Use <code>CommandSpecBuilder::fixed_result()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let builder = CommandSpecBuilder::new()
    .fixed_result(
        "data",
        TypeDef::Tabular,
        Some("Query results"),
        ResultKind::Data
    )
    .fixed_result(
        "row_count",
        TypeDef::Scalar(ScalarType::Number),
        Some("Number of rows returned"),
        ResultKind::Meta
    );
<span class="boring">}</span></code></pre>
<h3 id="when-to-use-6"><a class="header" href="#when-to-use-6">When to Use</a></h3>
<p>Use fixed results when:</p>
<ul>
<li>The command always produces the same named outputs</li>
<li>The number and names of results are constant</li>
<li>Other commands can depend on specific result names</li>
</ul>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A query command with fixed results
CommandSpecBuilder::new()
    .attribute(
        AttributeSpecBuilder::new("query", TypeDef::Scalar(ScalarType::String))
            .required()
            .build()
    )
    .fixed_result("rows", TypeDef::Tabular, None, ResultKind::Data)
    .fixed_result("columns", TypeDef::Scalar(ScalarType::Array), None, ResultKind::Meta)
    .build()
<span class="boring">}</span></code></pre>
<h2 id="derived-results-resultspecderivedfromsingleattribute"><a class="header" href="#derived-results-resultspecderivedfromsingleattribute">Derived Results (ResultSpec::DerivedFromSingleAttribute)</a></h2>
<p>Derived results have names determined by values in an array attribute.</p>
<h3 id="structure-1"><a class="header" href="#structure-1">Structure</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ResultSpec::DerivedFromSingleAttribute {
    attribute: T,                 // Name of the source attribute
    name_field: LiteralFieldRef&lt;T&gt;,  // Proof of which field provides names
    ty: Option&lt;TypeDef&lt;T&gt;&gt;,       // Type (None = inferred at runtime)
    kind: ResultKind,             // Data or Meta
}
<span class="boring">}</span></code></pre>
<h3 id="creating-derived-results"><a class="header" href="#creating-derived-results">Creating Derived Results</a></h3>
<p>Use <code>CommandSpecBuilder::derived_result()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (pending, fields) = CommandSpecBuilder::new()
    .array_of_objects("transforms", true, None);

let (fields, name_ref) = fields.add_literal(
    "name",
    TypeDef::Scalar(ScalarType::String),
    true,
    None
);

let fields = fields.add_template(
    "expression",
    TypeDef::Scalar(ScalarType::String),
    true,
    None,
    ReferenceKind::RuntimeTeraTemplate
);

let (attrs, results) = pending
    .finalise_attribute(fields)
    .derived_result(
        "transforms",  // Source attribute
        name_ref,      // LiteralFieldRef for name field
        None,          // Type inferred at runtime
        ResultKind::Data
    )
    .build();
<span class="boring">}</span></code></pre>
<h3 id="how-derived-results-work"><a class="header" href="#how-derived-results-work">How Derived Results Work</a></h3>
<p>Given this pipeline configuration:</p>
<pre><code class="language-yaml">my_transform:
  transforms:
    - name: "total"
      expression: "{{ item.a + item.b }}"
    - name: "average"
      expression: "{{ item.sum / item.count }}"
    - name: "maximum"
      expression: "{{ item.values | max }}"
</code></pre>
<p>The command produces three results:</p>
<ul>
<li><code>my_transform.total</code></li>
<li><code>my_transform.average</code></li>
<li><code>my_transform.maximum</code></li>
</ul>
<p>The names come from the <code>name</code> field of each object in the <code>transforms</code> array.</p>
<h3 id="when-to-use-1-3"><a class="header" href="#when-to-use-1-3">When to Use</a></h3>
<p>Use derived results when:</p>
<ul>
<li>The number of outputs depends on configuration</li>
<li>Users define what outputs they want</li>
<li>Each array element produces a named result</li>
</ul>
<h3 id="the-literalfieldref-requirement"><a class="header" href="#the-literalfieldref-requirement">The LiteralFieldRef Requirement</a></h3>
<p><code>derived_result()</code> requires a <code>LiteralFieldRef</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn derived_result(
    mut self,
    attribute: T,
    name_field: LiteralFieldRef&lt;T&gt;,  // Required proof
    ty: Option&lt;TypeDef&lt;T&gt;&gt;,
    kind: ResultKind,
) -&gt; Self
<span class="boring">}</span></code></pre>
<p>This ensures the name field contains literal values, not templates. See <a href="#literalfieldref-compile-time-safety">LiteralFieldRef</a> for details on why this matters.</p>
<h3 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h3>
<p>The <code>ty</code> parameter can be <code>None</code> to infer the type at runtime:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Type specified: all derived results are tabular
.derived_result("transforms", name_ref, Some(TypeDef::Tabular), ResultKind::Data)

// Type inferred: determined by actual values at runtime
.derived_result("transforms", name_ref, None, ResultKind::Data)
<span class="boring">}</span></code></pre>
<h2 id="build-time-validation-1"><a class="header" href="#build-time-validation-1">Build-Time Validation</a></h2>
<p>When <code>build()</code> is called, the builder validates derived results:</p>
<h3 id="1-attribute-must-exist"><a class="header" href="#1-attribute-must-exist">1. Attribute Must Exist</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (pending, fields) = builder.array_of_objects("things", true, None);
let (fields, name_ref) = fields.add_literal("name", ...);

pending
    .finalise_attribute(fields)
    .derived_result("nonexistent", name_ref, None, ResultKind::Data)
    .build();
// Panics: "Derived result references unknown attribute 'nonexistent'"
<span class="boring">}</span></code></pre>
<h3 id="2-attribute-must-be-arrayofobjectof"><a class="header" href="#2-attribute-must-be-arrayofobjectof">2. Attribute Must Be ArrayOf(ObjectOf)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>CommandSpecBuilder::new()
    .attribute(
        AttributeSpecBuilder::new("scalar_attr", TypeDef::Scalar(ScalarType::String))
            .build()
    )
    // ... somehow have a name_ref ...
    .derived_result("scalar_attr", name_ref, None, ResultKind::Data)
    .build();
// Panics: "Derived result attribute 'scalar_attr' must be ArrayOf(ObjectOf)"
<span class="boring">}</span></code></pre>
<h3 id="3-name-field-must-exist-in-attribute"><a class="header" href="#3-name-field-must-exist-in-attribute">3. Name Field Must Exist in Attribute</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (pending, fields) = builder.array_of_objects("items", true, None);
let (fields, wrong_ref) = fields.add_literal("key", ...);

// Use wrong_ref with a different attribute
pending
    .finalise_attribute(fields)
    .array_of_objects("other_items", true, None)
    // ... add different fields ...
    .derived_result("other_items", wrong_ref, None, ResultKind::Data)
    .build();
// Panics: "Derived result name_field 'key' not found in attribute 'other_items' fields"
<span class="boring">}</span></code></pre>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::extend::*;

fn define_multi_output_command() -&gt; (
    Vec&lt;AttributeSpec&lt;&amp;'static str&gt;&gt;,
    Vec&lt;ResultSpec&lt;&amp;'static str&gt;&gt;
) {
    let builder = CommandSpecBuilder::new();

    // Simple configuration attribute
    let builder = builder.attribute(
        AttributeSpecBuilder::new("source", TypeDef::Scalar(ScalarType::String))
            .required()
            .reference(ReferenceKind::StorePath)
            .hint("Input data path")
            .build()
    );

    // Array of output specifications
    let (pending, fields) = builder.array_of_objects(
        "outputs",
        true,
        Some("Output specifications")
    );

    // Literal name field - used for derived results
    let (fields, name_ref) = fields.add_literal(
        "name",
        TypeDef::Scalar(ScalarType::String),
        true,
        Some("Output name")
    );

    // Literal format field
    let (fields, _format_ref) = fields.add_literal(
        "format",
        TypeDef::Scalar(ScalarType::String),
        false,
        Some("Output format: json, csv, parquet")
    );

    // Template filter field
    let fields = fields.add_template(
        "filter",
        TypeDef::Scalar(ScalarType::String),
        false,
        Some("Filter expression"),
        ReferenceKind::RuntimeTeraTemplate
    );

    pending
        .finalise_attribute(fields)
        // Fixed metadata result
        .fixed_result(
            "summary",
            TypeDef::Scalar(ScalarType::Object),
            Some("Execution summary with timing and counts"),
            ResultKind::Meta
        )
        // Derived data results - one per output spec
        .derived_result(
            "outputs",
            name_ref,
            Some(TypeDef::Tabular),
            ResultKind::Data
        )
        .build()
}
<span class="boring">}</span></code></pre>
<h3 id="usage-in-pipeline"><a class="header" href="#usage-in-pipeline">Usage in Pipeline</a></h3>
<pre><code class="language-yaml">multi_output:
  source: "load_data.rows"
  outputs:
    - name: "filtered"
      filter: "{{ item.status == 'active' }}"
    - name: "transformed"
      format: "json"
    - name: "aggregated"
      filter: "{{ item.value &gt; 100 }}"
</code></pre>
<p>This produces:</p>
<ul>
<li><code>multi_output.summary</code> (fixed, Meta)</li>
<li><code>multi_output.filtered</code> (derived, Data)</li>
<li><code>multi_output.transformed</code> (derived, Data)</li>
<li><code>multi_output.aggregated</code> (derived, Data)</li>
</ul>
<h2 id="accessing-result-type"><a class="header" href="#accessing-result-type">Accessing Result Type</a></h2>
<p>The <code>ResultSpec</code> provides a helper method:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Into&lt;String&gt;&gt; ResultSpec&lt;T&gt; {
    pub fn type_def(&amp;self) -&gt; Option&lt;&amp;TypeDef&lt;T&gt;&gt; {
        match self {
            ResultSpec::Field { ty, .. } =&gt; Some(ty),
            ResultSpec::DerivedFromSingleAttribute { ty, .. } =&gt; ty.as_ref(),
        }
    }
}
<span class="boring">}</span></code></pre>
<p>For fixed results, this always returns <code>Some</code>. For derived results, it returns <code>None</code> if the type is inferred at runtime.</p>
<h2 id="fixed-vs-derived-decision-guide"><a class="header" href="#fixed-vs-derived-decision-guide">Fixed vs Derived: Decision Guide</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scenario</th><th>Use Fixed</th><th>Use Derived</th></tr>
</thead>
<tbody>
<tr><td>Command always produces same outputs</td><td>Yes</td><td></td></tr>
<tr><td>Number of outputs is configuration-driven</td><td></td><td>Yes</td></tr>
<tr><td>Output names are static</td><td>Yes</td><td></td></tr>
<tr><td>Output names come from user input</td><td></td><td>Yes</td></tr>
<tr><td>Need compile-time type checking</td><td>Yes</td><td></td></tr>
<tr><td>Type depends on runtime data</td><td></td><td>Yes (with <code>ty: None</code>)</td></tr>
</tbody>
</table>
</div>
<h2 id="combining-fixed-and-derived"><a class="header" href="#combining-fixed-and-derived">Combining Fixed and Derived</a></h2>
<p>A command can have both:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>builder
    // Fixed results (always present)
    .fixed_result("metadata", TypeDef::Scalar(ScalarType::Object), None, ResultKind::Meta)
    .fixed_result("errors", TypeDef::Tabular, None, ResultKind::Meta)
    // Derived results (depend on configuration)
    .derived_result("transforms", name_ref, None, ResultKind::Data)
    .build()
<span class="boring">}</span></code></pre>
<p>This pattern is common for commands that have predictable metadata outputs plus user-defined data outputs.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="working-with-executioncontext"><a class="header" href="#working-with-executioncontext">Working with ExecutionContext</a></h1>
<p>The <code>ExecutionContext</code> is passed to your command’s <code>execute</code> method and provides access to runtime resources needed during command execution. It serves as the central hub for:</p>
<ul>
<li>Reading and writing scalar values</li>
<li>Reading and writing tabular data</li>
<li>Template substitution with Tera</li>
<li>Shared state via type-indexed extensions</li>
<li>Pipeline services (IO and hooks)</li>
</ul>
<h2 id="the-executioncontext-struct"><a class="header" href="#the-executioncontext-struct">The ExecutionContext Struct</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ExecutionContext {
    services: PipelineServices,
    extensions: Extensions,
    scalar_store: ScalarStore,
    tabular_store: TabularStore,
}
<span class="boring">}</span></code></pre>
<p>All methods on <code>ExecutionContext</code> are designed to be called from async contexts and use internal <code>RwLock</code>s to ensure safe concurrent access.</p>
<h2 id="accessing-data-stores"><a class="header" href="#accessing-data-stores">Accessing Data Stores</a></h2>
<h3 id="scalarstore"><a class="header" href="#scalarstore">ScalarStore</a></h3>
<p>The <code>ScalarStore</code> holds key-value pairs where values are JSON-compatible scalars (strings, numbers, booleans, nulls, arrays, and objects). Access it via <code>context.scalar()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
impl Executable for MyCommand {
    async fn execute(&amp;self, context: &amp;ExecutionContext, output_prefix: &amp;StorePath) -&gt; Result&lt;()&gt; {
        let scalar_store = context.scalar();

        // Insert a value
        let path = output_prefix.with_segment("my_result");
        scalar_store.insert(&amp;path, ScalarValue::String("hello".to_string())).await?;

        // Retrieve a value
        if let Some(value) = scalar_store.get(&amp;path).await? {
            println!("Retrieved: {:?}", value);
        }

        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="tabularstore"><a class="header" href="#tabularstore">TabularStore</a></h3>
<p>The <code>TabularStore</code> holds Polars DataFrames for tabular data. Access it via <code>context.tabular()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use polars::prelude::*;

async fn execute(&amp;self, context: &amp;ExecutionContext, output_prefix: &amp;StorePath) -&gt; Result&lt;()&gt; {
    let tabular_store = context.tabular();

    // Create a DataFrame
    let df = df![
        "name" =&gt; ["Alice", "Bob"],
        "score" =&gt; [95, 87]
    ]?;

    // Insert the DataFrame
    let path = output_prefix.with_segment("results_table");
    tabular_store.insert(&amp;path, df).await?;

    // Retrieve later
    if let Some(retrieved_df) = tabular_store.get(&amp;path).await? {
        println!("Rows: {}", retrieved_df.height());
    }

    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="using-insertbatch-for-convenience"><a class="header" href="#using-insertbatch-for-convenience">Using InsertBatch for Convenience</a></h3>
<p>The <code>InsertBatch</code> helper provides a cleaner API for writing multiple values under a common prefix:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn execute(&amp;self, context: &amp;ExecutionContext, output_prefix: &amp;StorePath) -&gt; Result&lt;()&gt; {
    let out = InsertBatch::new(context, output_prefix);

    // These insert at output_prefix.reversed, output_prefix.length, etc.
    out.string("reversed", "dlrow olleh".to_string()).await?;
    out.u64("length", 11).await?;
    out.bool("success", true).await?;
    out.f64("processing_time", 0.042).await?;

    // For tabular data
    let df = /* ... */;
    out.tabular("data", df).await?;

    Ok(())
}
<span class="boring">}</span></code></pre>
<p>Available <code>InsertBatch</code> methods:</p>
<ul>
<li><code>string(segment, String)</code> - Insert a string value</li>
<li><code>i64(segment, i64)</code> - Insert a signed integer</li>
<li><code>u64(segment, u64)</code> - Insert an unsigned integer</li>
<li><code>f64(segment, f64)</code> - Insert a floating point number</li>
<li><code>bool(segment, bool)</code> - Insert a boolean</li>
<li><code>null(segment)</code> - Insert a null value</li>
<li><code>scalar(segment, ScalarValue)</code> - Insert any ScalarValue</li>
<li><code>tabular(segment, DataFrame)</code> - Insert a DataFrame</li>
</ul>
<h2 id="template-substitution-1"><a class="header" href="#template-substitution-1">Template Substitution</a></h2>
<p>The <code>substitute</code> method resolves Tera template expressions against the current scalar store:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn execute(&amp;self, context: &amp;ExecutionContext, output_prefix: &amp;StorePath) -&gt; Result&lt;()&gt; {
    // Assume self.input contains "Hello, {{ inputs.name }}!"
    // And inputs.name was set to "World" in a static namespace

    let resolved = context.substitute(&amp;self.input).await?;
    // resolved == "Hello, World!"

    Ok(())
}
<span class="boring">}</span></code></pre>
<p>This is particularly useful when command attributes support Tera template references. The substitution happens against all values currently in the scalar store, allowing commands to reference:</p>
<ul>
<li>Values from static namespaces</li>
<li>Results from previously executed commands</li>
<li>Any other scalar data in the context</li>
</ul>
<h3 id="template-syntax-2"><a class="header" href="#template-syntax-2">Template Syntax</a></h3>
<p>Templates use the Tera templating language:</p>
<pre><code>{{ namespace.key }}              # Simple variable access
{{ namespace.nested.value }}     # Nested object access
{{ value | upper }}              # Filters
{{ value | default(value="N/A") }}  # Default values
</code></pre>
<h2 id="using-extensions-for-shared-state"><a class="header" href="#using-extensions-for-shared-state">Using Extensions for Shared State</a></h2>
<p>The <code>Extensions</code> type provides a type-indexed registry for sharing state across commands. This is useful for:</p>
<ul>
<li>HTTP clients that should be reused</li>
<li>Authentication tokens</li>
<li>Database connection pools</li>
<li>Cancellation tokens</li>
<li>Any shared runtime state</li>
</ul>
<h3 id="reading-from-extensions"><a class="header" href="#reading-from-extensions">Reading from Extensions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define your extension type
struct HttpClient(reqwest::Client);

async fn execute(&amp;self, context: &amp;ExecutionContext, output_prefix: &amp;StorePath) -&gt; Result&lt;()&gt; {
    // Acquire a read lock
    let extensions = context.extensions().read().await;

    // Get the typed extension (returns Option&lt;&amp;T&gt;)
    if let Some(client) = extensions.get::&lt;HttpClient&gt;() {
        let response = client.0.get("https://api.example.com/data").send().await?;
        // ... process response
    }

    // Check if an extension exists
    if extensions.contains::&lt;HttpClient&gt;() {
        // ...
    }

    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="writing-to-extensions"><a class="header" href="#writing-to-extensions">Writing to Extensions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn execute(&amp;self, context: &amp;ExecutionContext, output_prefix: &amp;StorePath) -&gt; Result&lt;()&gt; {
    // Acquire a write lock
    let mut extensions = context.extensions().write().await;

    // Insert a new extension
    extensions.insert(HttpClient(reqwest::Client::new()));

    // Modify an existing extension
    if let Some(state) = extensions.get_mut::&lt;MyState&gt;() {
        state.counter += 1;
    }

    // Remove an extension
    let removed: Option&lt;HttpClient&gt; = extensions.remove::&lt;HttpClient&gt;();

    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="built-in-extensions"><a class="header" href="#built-in-extensions">Built-in Extensions</a></h3>
<p>By default, <code>Extensions</code> includes a <code>CancellationToken</code> from <code>tokio_util</code>. You can check for cancellation in long-running operations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn execute(&amp;self, context: &amp;ExecutionContext, output_prefix: &amp;StorePath) -&gt; Result&lt;()&gt; {
    // Check if cancellation was requested
    if context.extensions().is_canceled().await {
        return Err(anyhow::anyhow!("Operation cancelled"));
    }

    // For long loops, check periodically
    for item in large_dataset {
        if context.extensions().is_canceled().await {
            break;
        }
        // ... process item
    }

    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="extension-type-requirements"><a class="header" href="#extension-type-requirements">Extension Type Requirements</a></h3>
<p>Extension types must satisfy:</p>
<ul>
<li><code>Send + Sync + 'static</code> - Safe to share across threads</li>
<li>Each type can only have one instance in the registry (indexed by <code>TypeId</code>)</li>
</ul>
<p>A common pattern is to wrap standard types in newtypes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Wrap reqwest::Client so it has a unique TypeId
struct ApiClient(reqwest::Client);

// Wrap a String to store an auth token
struct AuthToken(String);

// Now these can coexist in Extensions
extensions.insert(ApiClient(reqwest::Client::new()));
extensions.insert(AuthToken("bearer xyz...".to_string()));
<span class="boring">}</span></code></pre>
<h2 id="accessing-pipelineservices"><a class="header" href="#accessing-pipelineservices">Accessing PipelineServices</a></h2>
<p>The <code>services()</code> method provides access to <code>PipelineServices</code>, which manages IO and event hooks:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn execute(&amp;self, context: &amp;ExecutionContext, output_prefix: &amp;StorePath) -&gt; Result&lt;()&gt; {
    let services = context.services();

    // Send a notification to all registered IO services
    services.notify("Processing started...").await?;

    // Prompt for user input (returns first response from any IO service)
    if let Some(response) = services.prompt("Continue? (y/n)").await? {
        if response != "y" {
            return Ok(());
        }
    }

    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="pipelineio-trait"><a class="header" href="#pipelineio-trait">PipelineIO Trait</a></h3>
<p>Commands can interact with users through any registered <code>PipelineIO</code> implementation:</p>
<ul>
<li><code>notify(message)</code> - Send a one-way notification</li>
<li><code>prompt(message)</code> - Request input and wait for a response</li>
</ul>
<p>Multiple IO services can be registered (CLI, GUI, channel-based, etc.). Notifications go to all services; prompts return the first response.</p>
<h2 id="complete-example-2"><a class="header" href="#complete-example-2">Complete Example</a></h2>
<p>Here is a complete command demonstrating multiple <code>ExecutionContext</code> features:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FetchDataCommand {
    url: String,
    output_name: String,
}

#[async_trait]
impl Executable for FetchDataCommand {
    async fn execute(&amp;self, context: &amp;ExecutionContext, output_prefix: &amp;StorePath) -&gt; Result&lt;()&gt; {
        // Resolve any templates in the URL
        let url = context.substitute(&amp;self.url).await?;

        // Get the HTTP client from extensions
        let client = {
            let extensions = context.extensions().read().await;
            extensions.get::&lt;HttpClient&gt;()
                .map(|c| c.0.clone())
                .unwrap_or_else(reqwest::Client::new)
        };

        // Notify the user
        context.services().notify(&amp;format!("Fetching data from {}", url)).await?;

        // Check for cancellation before the request
        if context.extensions().is_canceled().await {
            return Err(anyhow::anyhow!("Cancelled before fetch"));
        }

        // Make the request
        let response = client.get(&amp;url).send().await?;
        let status = response.status().as_u16();
        let body = response.text().await?;

        // Write results using InsertBatch
        let out = InsertBatch::new(context, output_prefix);
        out.string(&amp;self.output_name, body).await?;
        out.u64("status_code", status as u64).await?;
        out.bool("success", status &gt;= 200 &amp;&amp; status &lt; 300).await?;

        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Returns</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>scalar()</code></td><td><code>&amp;ScalarStore</code></td><td>Access scalar key-value storage</td></tr>
<tr><td><code>tabular()</code></td><td><code>&amp;TabularStore</code></td><td>Access DataFrame storage</td></tr>
<tr><td><code>substitute(template)</code></td><td><code>Result&lt;String&gt;</code></td><td>Resolve Tera templates</td></tr>
<tr><td><code>extensions()</code></td><td><code>&amp;Extensions</code></td><td>Access type-indexed shared state</td></tr>
<tr><td><code>services()</code></td><td><code>&amp;PipelineServices</code></td><td>Access IO and hook services</td></tr>
</tbody>
</table>
</div>
<p>The async nature of store operations ensures thread-safe access when commands execute concurrently. Always <code>.await</code> the store methods and handle potential errors appropriately.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="services-overview"><a class="header" href="#services-overview">Services Overview</a></h1>
<p>Pipeline services provide extensibility points for interacting with the outside world during pipeline execution. The <code>PipelineServices</code> struct bundles two categories of functionality that you can customize:</p>
<ul>
<li><strong>PipelineIO</strong> - Handles user interaction (notifications and prompts)</li>
<li><strong>EventHooks</strong> - Responds to pipeline lifecycle events</li>
</ul>
<p>This section covers how to implement your own services. For using the built-in services, see the <a href="../guide/src/services-and-io/index.html">Guide: Services &amp; IO</a>.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>The services architecture is designed around two key principles:</p>
<ol>
<li><strong>Multiple services can coexist</strong> - You can register multiple IO services and multiple hook implementations. They all receive events and notifications.</li>
<li><strong>Errors are aggregated, not short-circuited</strong> - When multiple services are registered, all of them are called even if one fails. Errors are collected and returned together.</li>
</ol>
<pre><code>┌─────────────────────────────────────────────────────────────────────┐
│                        PipelineServices                             │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    IO Services (Vec)                         │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │   │
│  │  │ StdoutIO     │  │ WebSocketIO  │  │ ChannelIO    │       │   │
│  │  │ (built-in)   │  │ (custom)     │  │ (custom)     │       │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘       │   │
│  └─────────────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                   Event Hooks (Vec)                          │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │   │
│  │  │ DebugHooks   │  │ MetricsHooks │  │ AuditHooks   │       │   │
│  │  │ (built-in)   │  │ (custom)     │  │ (custom)     │       │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘       │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="the-pipelineservices-struct"><a class="header" href="#the-pipelineservices-struct">The PipelineServices Struct</a></h2>
<p><code>PipelineServices</code> is the container that holds all registered services:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::prelude::*;

// Create empty services
let mut services = PipelineServices::new();

// Or use defaults (includes debug hooks in debug builds)
let mut services = PipelineServices::defaults();
<span class="boring">}</span></code></pre>
<h3 id="registering-services"><a class="header" href="#registering-services">Registering Services</a></h3>
<p>Add your custom services using <code>add_io()</code> and <code>add_hook()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::prelude::*;

let mut services = PipelineServices::new();

// Register IO services
services.add_io(MyCustomIO::new());
services.add_io(AnotherIO::new());

// Register event hooks
services.add_hook(MetricsHooks::new());
services.add_hook(AuditHooks::new());

// Attach to pipeline
let pipeline = Pipeline::with_services(services);
<span class="boring">}</span></code></pre>
<h3 id="default-services-by-build-mode"><a class="header" href="#default-services-by-build-mode">Default Services by Build Mode</a></h3>
<p><code>PipelineServices::defaults()</code> provides different services depending on compilation mode:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Build Mode</th><th>IO Service</th><th>Event Hooks</th></tr>
</thead>
<tbody>
<tr><td>Debug (<code>cfg(debug_assertions)</code>)</td><td><code>StdoutInteraction</code></td><td><code>DebugEventHooks</code></td></tr>
<tr><td>Release</td><td>None</td><td>None</td></tr>
</tbody>
</table>
</div>
<p>This gives you verbose logging during development without impacting production performance.</p>
<h2 id="service-dispatch-behavior"><a class="header" href="#service-dispatch-behavior">Service Dispatch Behavior</a></h2>
<p>Understanding how services are dispatched helps you design robust implementations.</p>
<h3 id="io-dispatch-notify-vs-prompt"><a class="header" href="#io-dispatch-notify-vs-prompt">IO Dispatch: Notify vs Prompt</a></h3>
<p><strong><code>notify(message)</code></strong> - Broadcasts to all registered IO services:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All IO services receive the notification
// Errors are collected, not short-circuited
ctx.services().notify("Processing complete").await?;
<span class="boring">}</span></code></pre>
<p><strong><code>prompt(message)</code></strong> - Returns first non-None response:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Services are tried in order until one returns Some(response)
if let Some(answer) = ctx.services().prompt("Continue?").await? {
    // First service that returned Some wins
}
<span class="boring">}</span></code></pre>
<h3 id="hook-dispatch-aggregate-errors"><a class="header" href="#hook-dispatch-aggregate-errors">Hook Dispatch: Aggregate Errors</a></h3>
<p>All registered hooks are called for every event. If any hook returns an error, errors are collected and returned as a combined error message:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Internal dispatch logic (simplified)
let mut errors = Vec::new();
for hook in &amp;self.hooks {
    if let Err(e) = hook.before_execute_command(&amp;event).await {
        errors.push(e);
    }
}
// All hooks ran - errors are combined at the end
<span class="boring">}</span></code></pre>
<p>This ensures that one failing hook does not prevent other hooks from running. For example, a logging hook failure should not prevent a metrics hook from recording data.</p>
<h2 id="implementing-custom-services"><a class="header" href="#implementing-custom-services">Implementing Custom Services</a></h2>
<p>The following sections cover implementation details for each service type:</p>
<ul>
<li><strong><a href="#implementing-pipelineio">PipelineIO</a></strong> - Implement custom notification and prompting</li>
<li><strong><a href="#event-hooks">Event Hooks</a></strong> - Implement lifecycle callbacks</li>
<li><strong><a href="#hook-events">Hook Events</a></strong> - Reference for all event types and their fields</li>
</ul>
<h2 id="complete-example-custom-services"><a class="header" href="#complete-example-custom-services">Complete Example: Custom Services</a></h2>
<p>Here is a complete example showing both custom services working together:</p>
<pre class="playground"><code class="language-rust">use panopticon_core::prelude::*;
use async_trait::async_trait;

// Custom IO that logs to a file
pub struct FileLoggerIO {
    path: std::path::PathBuf,
}

#[async_trait]
impl PipelineIO for FileLoggerIO {
    async fn notify(&amp;self, message: &amp;str) -&gt; Result&lt;()&gt; {
        use std::io::Write;
        let mut file = std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&amp;self.path)?;
        writeln!(file, "[NOTIFY] {}", message)?;
        Ok(())
    }

    async fn prompt(&amp;self, _message: &amp;str) -&gt; Result&lt;Option&lt;String&gt;&gt; {
        // File logger cannot prompt - return None to let other services handle it
        Ok(None)
    }
}

// Custom hooks that track execution timing
pub struct TimingHooks {
    start_times: std::sync::Mutex&lt;std::collections::HashMap&lt;String, std::time::Instant&gt;&gt;,
}

#[async_trait]
impl EventHooks for TimingHooks {
    async fn before_execute_command(&amp;self, event: &amp;hook_events::CommandInfo) -&gt; Result&lt;()&gt; {
        let mut times = self.start_times.lock().unwrap();
        times.insert(event.command_name.clone(), std::time::Instant::now());
        Ok(())
    }

    async fn after_execute_command(&amp;self, event: &amp;hook_events::CommandExecuted) -&gt; Result&lt;()&gt; {
        let times = self.start_times.lock().unwrap();
        if let Some(start) = times.get(&amp;event.command_name) {
            let elapsed = start.elapsed();
            println!("Command '{}' took {:?}", event.command_name, elapsed);
        }
        Ok(())
    }
}

// Usage
fn main() {
    let mut services = PipelineServices::new();
    services.add_io(FileLoggerIO { path: "pipeline.log".into() });
    services.add_hook(TimingHooks {
        start_times: std::sync::Mutex::new(std::collections::HashMap::new())
    });

    let pipeline = Pipeline::with_services(services);
}</code></pre>
<h2 id="when-to-use-services"><a class="header" href="#when-to-use-services">When to Use Services</a></h2>
<p>Services are appropriate for cross-cutting concerns that should not be embedded in command logic:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Service Type</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>Progress reporting</td><td>PipelineIO</td><td>WebSocket updates to UI</td></tr>
<tr><td>User confirmation</td><td>PipelineIO</td><td>CLI prompts before destructive operations</td></tr>
<tr><td>Logging</td><td>EventHooks</td><td>Structured logging to observability platform</td></tr>
<tr><td>Metrics</td><td>EventHooks</td><td>Execution timing, command counts</td></tr>
<tr><td>Auditing</td><td>EventHooks</td><td>Recording who ran what and when</td></tr>
<tr><td>Debugging</td><td>EventHooks</td><td>Printing pipeline state during development</td></tr>
</tbody>
</table>
</div>
<p>For command-specific logic (e.g., “notify when this specific file is processed”), consider handling it within the command itself rather than in a service.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="implementing-pipelineio"><a class="header" href="#implementing-pipelineio">Implementing PipelineIO</a></h1>
<p>The <code>PipelineIO</code> trait defines how pipelines communicate with the outside world for user interaction. Implement this trait to create custom notification channels, prompting mechanisms, or integration with external systems.</p>
<h2 id="the-pipelineio-trait"><a class="header" href="#the-pipelineio-trait">The PipelineIO Trait</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait PipelineIO: Send + Sync {
    async fn notify(&amp;self, message: &amp;str) -&gt; Result&lt;()&gt; {
        Ok(())
    }

    async fn prompt(&amp;self, message: &amp;str) -&gt; Result&lt;Option&lt;String&gt;&gt; {
        Ok(None)
    }
}
<span class="boring">}</span></code></pre>
<p>Both methods have default implementations that do nothing. This means you only need to implement the methods relevant to your use case.</p>
<h3 id="trait-bounds"><a class="header" href="#trait-bounds">Trait Bounds</a></h3>
<ul>
<li><strong><code>Send + Sync</code></strong> - IO services must be thread-safe because pipelines may execute across multiple threads</li>
<li><strong><code>async</code></strong> - Both methods are async to support network-based IO (WebSocket, HTTP, etc.)</li>
</ul>
<h2 id="method-reference"><a class="header" href="#method-reference">Method Reference</a></h2>
<h3 id="notifymessage-str---result"><a class="header" href="#notifymessage-str---result"><code>notify(message: &amp;str) -&gt; Result&lt;()&gt;</code></a></h3>
<p>Sends a one-way notification. The caller does not expect a response.</p>
<p><strong>Behavior:</strong></p>
<ul>
<li>Called on all registered IO services</li>
<li>Errors from all services are aggregated</li>
<li>Fire-and-forget from the command’s perspective</li>
</ul>
<p><strong>Common implementations:</strong></p>
<ul>
<li>Print to stdout/stderr</li>
<li>Write to a log file</li>
<li>Send via WebSocket to a UI</li>
<li>Post to a message queue</li>
</ul>
<h3 id="promptmessage-str---resultoptionstring"><a class="header" href="#promptmessage-str---resultoptionstring"><code>prompt(message: &amp;str) -&gt; Result&lt;Option&lt;String&gt;&gt;</code></a></h3>
<p>Requests input from the user. Returns <code>Some(response)</code> if the service can provide an answer, or <code>None</code> to defer to other services.</p>
<p><strong>Behavior:</strong></p>
<ul>
<li>Services are tried in order of registration</li>
<li>First <code>Some(response)</code> is returned to the caller</li>
<li>If all services return <code>None</code>, the prompt returns <code>None</code></li>
</ul>
<p><strong>Return values:</strong></p>
<ul>
<li><code>Ok(Some(string))</code> - This service handled the prompt</li>
<li><code>Ok(None)</code> - This service cannot handle prompts (defer to others)</li>
<li><code>Err(...)</code> - Something went wrong</li>
</ul>
<h2 id="built-in-implementation-stdoutinteraction"><a class="header" href="#built-in-implementation-stdoutinteraction">Built-in Implementation: StdoutInteraction</a></h2>
<p>Panopticon includes <code>StdoutInteraction</code> for CLI applications:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct StdoutInteraction;

#[async_trait]
impl PipelineIO for StdoutInteraction {
    async fn notify(&amp;self, message: &amp;str) -&gt; Result&lt;()&gt; {
        println!("{message}");
        Ok(())
    }

    async fn prompt(&amp;self, message: &amp;str) -&gt; Result&lt;Option&lt;String&gt;&gt; {
        println!("{message}");
        let mut input = String::new();
        std::io::stdin().read_line(&amp;mut input)?;
        Ok(match input.trim() {
            "" =&gt; None,
            _ =&gt; Some(input.trim().to_string()),
        })
    }
}
<span class="boring">}</span></code></pre>
<p>This implementation:</p>
<ul>
<li>Prints notifications to stdout</li>
<li>Displays prompt messages and reads from stdin</li>
<li>Returns <code>None</code> for empty input (just pressing Enter)</li>
</ul>
<h2 id="example-websocket-io"><a class="header" href="#example-websocket-io">Example: WebSocket IO</a></h2>
<p>For web applications, you might send notifications over WebSocket:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::prelude::*;
use async_trait::async_trait;
use tokio::sync::mpsc;

pub struct WebSocketIO {
    sender: mpsc::Sender&lt;String&gt;,
}

impl WebSocketIO {
    pub fn new(sender: mpsc::Sender&lt;String&gt;) -&gt; Self {
        Self { sender }
    }
}

#[async_trait]
impl PipelineIO for WebSocketIO {
    async fn notify(&amp;self, message: &amp;str) -&gt; Result&lt;()&gt; {
        self.sender
            .send(format!(r#"{{"type":"notify","message":"{}"}}"#, message))
            .await
            .map_err(|e| anyhow::anyhow!("Failed to send notification: {}", e))?;
        Ok(())
    }

    async fn prompt(&amp;self, _message: &amp;str) -&gt; Result&lt;Option&lt;String&gt;&gt; {
        // WebSocket IO is one-way in this example
        // For bidirectional prompts, you would need request/response channels
        Ok(None)
    }
}
<span class="boring">}</span></code></pre>
<h2 id="example-channel-based-io"><a class="header" href="#example-channel-based-io">Example: Channel-based IO</a></h2>
<p>For embedding pipelines in larger applications, channels provide clean integration:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::prelude::*;
use async_trait::async_trait;
use tokio::sync::{mpsc, oneshot};

pub enum IOMessage {
    Notify(String),
    Prompt {
        message: String,
        response: oneshot::Sender&lt;Option&lt;String&gt;&gt;,
    },
}

pub struct ChannelIO {
    sender: mpsc::Sender&lt;IOMessage&gt;,
}

impl ChannelIO {
    pub fn new(sender: mpsc::Sender&lt;IOMessage&gt;) -&gt; Self {
        Self { sender }
    }
}

#[async_trait]
impl PipelineIO for ChannelIO {
    async fn notify(&amp;self, message: &amp;str) -&gt; Result&lt;()&gt; {
        self.sender
            .send(IOMessage::Notify(message.to_string()))
            .await
            .map_err(|e| anyhow::anyhow!("Channel send failed: {}", e))?;
        Ok(())
    }

    async fn prompt(&amp;self, message: &amp;str) -&gt; Result&lt;Option&lt;String&gt;&gt; {
        let (tx, rx) = oneshot::channel();

        self.sender
            .send(IOMessage::Prompt {
                message: message.to_string(),
                response: tx,
            })
            .await
            .map_err(|e| anyhow::anyhow!("Channel send failed: {}", e))?;

        rx.await.map_err(|e| anyhow::anyhow!("Response channel closed: {}", e))
    }
}
<span class="boring">}</span></code></pre>
<p>Usage in your application:</p>
<pre class="playground"><code class="language-rust">use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    let (tx, mut rx) = mpsc::channel::&lt;IOMessage&gt;(100);

    // Spawn handler for IO messages
    tokio::spawn(async move {
        while let Some(msg) = rx.recv().await {
            match msg {
                IOMessage::Notify(message) =&gt; {
                    // Update your UI
                    println!("Pipeline says: {}", message);
                }
                IOMessage::Prompt { message, response } =&gt; {
                    // Show dialog, get user input
                    let answer = show_dialog(&amp;message).await;
                    let _ = response.send(answer);
                }
            }
        }
    });

    // Create pipeline with channel IO
    let mut services = PipelineServices::new();
    services.add_io(ChannelIO::new(tx));

    let pipeline = Pipeline::with_services(services);
    // ... use pipeline
}</code></pre>
<h2 id="example-quiet-io-no-op"><a class="header" href="#example-quiet-io-no-op">Example: Quiet IO (No-op)</a></h2>
<p>For batch processing where you want to suppress all output:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::prelude::*;
use async_trait::async_trait;

pub struct QuietIO;

#[async_trait]
impl PipelineIO for QuietIO {
    // Use default implementations - both return Ok with no action
}
<span class="boring">}</span></code></pre>
<p>Or equivalently, just do not register any IO services:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let services = PipelineServices::new(); // No IO services
<span class="boring">}</span></code></pre>
<h2 id="example-multi-destination-io"><a class="header" href="#example-multi-destination-io">Example: Multi-destination IO</a></h2>
<p>Combine multiple outputs in a single service:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::prelude::*;
use async_trait::async_trait;
use std::io::Write;

pub struct MultiIO {
    log_path: std::path::PathBuf,
    verbose: bool,
}

#[async_trait]
impl PipelineIO for MultiIO {
    async fn notify(&amp;self, message: &amp;str) -&gt; Result&lt;()&gt; {
        // Always log to file
        let mut file = std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&amp;self.log_path)?;
        writeln!(file, "[{}] {}", chrono::Utc::now(), message)?;

        // Optionally print to console
        if self.verbose {
            println!("{}", message);
        }

        Ok(())
    }

    async fn prompt(&amp;self, message: &amp;str) -&gt; Result&lt;Option&lt;String&gt;&gt; {
        // Log the prompt
        let mut file = std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&amp;self.log_path)?;
        writeln!(file, "[{}] PROMPT: {}", chrono::Utc::now(), message)?;

        // Read from stdin
        println!("{}", message);
        let mut input = String::new();
        std::io::stdin().read_line(&amp;mut input)?;

        let response = input.trim();
        writeln!(file, "[{}] RESPONSE: {}", chrono::Utc::now(), response)?;

        Ok(if response.is_empty() { None } else { Some(response.to_string()) })
    }
}
<span class="boring">}</span></code></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>IO errors are aggregated when multiple services are registered. If your <code>notify</code> returns an error, it will be combined with errors from other IO services:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// If StdoutIO succeeds but FileIO fails:
// Err(anyhow!("IO service errors: Failed to write to file: permission denied"))

// If both fail:
// Err(anyhow!("IO service errors: stdout closed; Failed to write to file: permission denied"))
<span class="boring">}</span></code></pre>
<p>This aggregation ensures all services attempt their operation before failing.</p>
<h3 id="recommended-error-handling-patterns"><a class="header" href="#recommended-error-handling-patterns">Recommended Error Handling Patterns</a></h3>
<p><strong>Non-critical IO (logging):</strong> Consider catching errors internally:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn notify(&amp;self, message: &amp;str) -&gt; Result&lt;()&gt; {
    if let Err(e) = self.try_log(message).await {
        eprintln!("Warning: logging failed: {}", e);
    }
    Ok(()) // Don't propagate - logging failure shouldn't stop the pipeline
}
<span class="boring">}</span></code></pre>
<p><strong>Critical IO (audit logs):</strong> Propagate errors:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn notify(&amp;self, message: &amp;str) -&gt; Result&lt;()&gt; {
    self.audit_log(message)
        .await
        .context("Audit logging is required for compliance")?;
    Ok(())
}
<span class="boring">}</span></code></pre>
<h2 id="registering-your-io-service"><a class="header" href="#registering-your-io-service">Registering Your IO Service</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::prelude::*;

let mut services = PipelineServices::new();

// Add your custom IO
services.add_io(MyCustomIO::new());

// You can add multiple IO services
services.add_io(StdoutInteraction);  // Also print to console
services.add_io(FileLoggerIO::new("pipeline.log"));

let pipeline = Pipeline::with_services(services);
<span class="boring">}</span></code></pre>
<h2 id="accessing-io-from-commands"><a class="header" href="#accessing-io-from-commands">Accessing IO from Commands</a></h2>
<p>Inside a command’s <code>execute</code> method:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Command for MyCommand {
    async fn execute(&amp;self, ctx: &amp;mut ExecutionContext) -&gt; Result&lt;()&gt; {
        // Send notification
        ctx.services().notify("Starting MyCommand...").await?;

        // Prompt for confirmation
        if let Some(answer) = ctx.services().prompt("Delete all files? (yes/no)").await? {
            if answer.to_lowercase() == "yes" {
                // Proceed with deletion
            }
        }

        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h2 id="testing-io-services"><a class="header" href="#testing-io-services">Testing IO Services</a></h2>
<p>Create a mock IO for testing that captures messages:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};

pub struct MockIO {
    notifications: Arc&lt;Mutex&lt;Vec&lt;String&gt;&gt;&gt;,
    prompts: Arc&lt;Mutex&lt;Vec&lt;String&gt;&gt;&gt;,
    responses: Arc&lt;Mutex&lt;Vec&lt;Option&lt;String&gt;&gt;&gt;&gt;,
}

impl MockIO {
    pub fn new() -&gt; Self {
        Self {
            notifications: Arc::new(Mutex::new(Vec::new())),
            prompts: Arc::new(Mutex::new(Vec::new())),
            responses: Arc::new(Mutex::new(Vec::new())),
        }
    }

    pub fn with_responses(responses: Vec&lt;Option&lt;String&gt;&gt;) -&gt; Self {
        Self {
            notifications: Arc::new(Mutex::new(Vec::new())),
            prompts: Arc::new(Mutex::new(Vec::new())),
            responses: Arc::new(Mutex::new(responses)),
        }
    }

    pub fn notifications(&amp;self) -&gt; Vec&lt;String&gt; {
        self.notifications.lock().unwrap().clone()
    }

    pub fn prompts(&amp;self) -&gt; Vec&lt;String&gt; {
        self.prompts.lock().unwrap().clone()
    }
}

#[async_trait]
impl PipelineIO for MockIO {
    async fn notify(&amp;self, message: &amp;str) -&gt; Result&lt;()&gt; {
        self.notifications.lock().unwrap().push(message.to_string());
        Ok(())
    }

    async fn prompt(&amp;self, message: &amp;str) -&gt; Result&lt;Option&lt;String&gt;&gt; {
        self.prompts.lock().unwrap().push(message.to_string());
        let mut responses = self.responses.lock().unwrap();
        Ok(if responses.is_empty() {
            None
        } else {
            responses.remove(0)
        })
    }
}

#[test]
fn test_command_notifications() {
    let mock = MockIO::new();
    let mut services = PipelineServices::new();
    services.add_io(mock.clone());

    // Run pipeline...

    assert_eq!(mock.notifications(), vec!["Starting...", "Complete!"]);
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="event-hooks"><a class="header" href="#event-hooks">Event Hooks</a></h1>
<p>The <code>EventHooks</code> trait lets you observe and react to pipeline lifecycle events without modifying command logic. Hooks are ideal for cross-cutting concerns like logging, metrics, auditing, and debugging.</p>
<h2 id="the-eventhooks-trait"><a class="header" href="#the-eventhooks-trait">The EventHooks Trait</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait EventHooks: Send + Sync {
    // Draft phase
    async fn after_added_namespace(&amp;self, event: &amp;hook_events::NamespaceInit) -&gt; Result&lt;()&gt; { Ok(()) }
    async fn after_added_command(&amp;self, event: &amp;hook_events::CommandInit) -&gt; Result&lt;()&gt; { Ok(()) }
    async fn before_compile_pipeline(&amp;self, event: &amp;hook_events::PipelineInfo) -&gt; Result&lt;()&gt; { Ok(()) }
    async fn after_compile_pipeline(&amp;self, event: &amp;hook_events::PipelineCompiled) -&gt; Result&lt;()&gt; { Ok(()) }

    // Ready phase
    async fn before_execute_pipeline(&amp;self, event: &amp;hook_events::PipelineInfo) -&gt; Result&lt;()&gt; { Ok(()) }
    async fn after_execute_pipeline(&amp;self, event: &amp;hook_events::PipelineExecuted) -&gt; Result&lt;()&gt; { Ok(()) }
    async fn before_execute_namespace(&amp;self, event: &amp;hook_events::NamespaceInfo) -&gt; Result&lt;()&gt; { Ok(()) }
    async fn after_execute_namespace(&amp;self, event: &amp;hook_events::NamespaceExecuted) -&gt; Result&lt;()&gt; { Ok(()) }
    async fn before_execute_command(&amp;self, event: &amp;hook_events::CommandInfo) -&gt; Result&lt;()&gt; { Ok(()) }
    async fn after_execute_command(&amp;self, event: &amp;hook_events::CommandExecuted) -&gt; Result&lt;()&gt; { Ok(()) }

    // Completed phase
    async fn on_results_start(&amp;self, event: &amp;hook_events::PipelineInfo) -&gt; Result&lt;()&gt; { Ok(()) }
    async fn on_results_finish(&amp;self, event: &amp;hook_events::PipelineCompleted) -&gt; Result&lt;()&gt; { Ok(()) }
}
<span class="boring">}</span></code></pre>
<p>All methods have default no-op implementations. Only override the hooks you care about.</p>
<h3 id="trait-bounds-1"><a class="header" href="#trait-bounds-1">Trait Bounds</a></h3>
<ul>
<li><strong><code>Send + Sync</code></strong> - Hooks must be thread-safe for concurrent execution</li>
<li><strong><code>async</code></strong> - All hooks are async for consistency and to support async operations (logging to remote services, etc.)</li>
</ul>
<h2 id="hook-reference-table"><a class="header" href="#hook-reference-table">Hook Reference Table</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Hook</th><th>Phase</th><th>Event Type</th><th>Fires When</th></tr>
</thead>
<tbody>
<tr><td><code>after_added_namespace</code></td><td>Draft</td><td><code>NamespaceInit</code></td><td>A namespace is added to the pipeline</td></tr>
<tr><td><code>after_added_command</code></td><td>Draft</td><td><code>CommandInit</code></td><td>A command is added to a namespace</td></tr>
<tr><td><code>before_compile_pipeline</code></td><td>Draft</td><td><code>PipelineInfo</code></td><td>Just before <code>compile()</code> validates the pipeline</td></tr>
<tr><td><code>after_compile_pipeline</code></td><td>Draft</td><td><code>PipelineCompiled</code></td><td>After successful compilation, pipeline is now Ready</td></tr>
<tr><td><code>before_execute_pipeline</code></td><td>Ready</td><td><code>PipelineInfo</code></td><td>Just before <code>execute()</code> starts</td></tr>
<tr><td><code>after_execute_pipeline</code></td><td>Ready</td><td><code>PipelineExecuted</code></td><td>After all namespaces have executed</td></tr>
<tr><td><code>before_execute_namespace</code></td><td>Ready</td><td><code>NamespaceInfo</code></td><td>Just before a namespace starts executing</td></tr>
<tr><td><code>after_execute_namespace</code></td><td>Ready</td><td><code>NamespaceExecuted</code></td><td>After a namespace finishes executing</td></tr>
<tr><td><code>before_execute_command</code></td><td>Ready</td><td><code>CommandInfo</code></td><td>Just before a command executes</td></tr>
<tr><td><code>after_execute_command</code></td><td>Ready</td><td><code>CommandExecuted</code></td><td>After a command finishes executing</td></tr>
<tr><td><code>on_results_start</code></td><td>Completed</td><td><code>PipelineInfo</code></td><td>When <code>results()</code> is called</td></tr>
<tr><td><code>on_results_finish</code></td><td>Completed</td><td><code>PipelineCompleted</code></td><td>After results collection completes</td></tr>
</tbody>
</table>
</div>
<h2 id="pipeline-phases"><a class="header" href="#pipeline-phases">Pipeline Phases</a></h2>
<p>Hooks are organized by the pipeline state machine phase in which they fire.</p>
<h3 id="draft-phase"><a class="header" href="#draft-phase">Draft Phase</a></h3>
<p>The Draft phase covers pipeline construction and compilation.</p>
<pre><code>Pipeline::new()
    │
    ├─► add_namespace() ──► after_added_namespace
    │       │
    │       └─► add_command() ──► after_added_command
    │
    └─► compile()
            │
            ├─► before_compile_pipeline
            │
            └─► after_compile_pipeline
                    │
                    ▼
              Pipeline&lt;Ready&gt;
</code></pre>
<p><strong><code>after_added_namespace</code></strong> - Fires each time a namespace is registered. Useful for:</p>
<ul>
<li>Validating namespace names against a whitelist</li>
<li>Recording namespace registration for debugging</li>
<li>Initializing per-namespace state in your hooks</li>
</ul>
<p><strong><code>after_added_command</code></strong> - Fires each time a command is added. Useful for:</p>
<ul>
<li>Logging command configuration</li>
<li>Validating command types are allowed</li>
<li>Building command inventories</li>
</ul>
<p><strong><code>before_compile_pipeline</code></strong> - Fires before validation runs. Useful for:</p>
<ul>
<li>Pre-compilation logging</li>
<li>Injecting additional validation</li>
<li>Recording pipeline structure before any transformation</li>
</ul>
<p><strong><code>after_compile_pipeline</code></strong> - Fires after successful compilation. Useful for:</p>
<ul>
<li>Logging the compiled pipeline structure</li>
<li>Sending “pipeline ready” notifications</li>
<li>Initializing execution-phase state</li>
</ul>
<h3 id="ready-phase"><a class="header" href="#ready-phase">Ready Phase</a></h3>
<p>The Ready phase covers pipeline execution.</p>
<pre><code>Pipeline&lt;Ready&gt;::execute()
    │
    ├─► before_execute_pipeline
    │
    ├─► for each namespace:
    │       │
    │       ├─► before_execute_namespace
    │       │
    │       ├─► for each command:
    │       │       │
    │       │       ├─► before_execute_command
    │       │       │
    │       │       └─► after_execute_command
    │       │
    │       └─► after_execute_namespace
    │
    └─► after_execute_pipeline
            │
            ▼
      Pipeline&lt;Completed&gt;
</code></pre>
<p><strong><code>before_execute_pipeline</code></strong> - Fires once when execution starts. Useful for:</p>
<ul>
<li>Starting execution timers</li>
<li>Logging “pipeline started”</li>
<li>Acquiring resources needed during execution</li>
</ul>
<p><strong><code>after_execute_pipeline</code></strong> - Fires once when all commands complete. Useful for:</p>
<ul>
<li>Stopping execution timers</li>
<li>Logging “pipeline finished”</li>
<li>Releasing execution resources</li>
</ul>
<p><strong><code>before_execute_namespace</code></strong> / <strong><code>after_execute_namespace</code></strong> - Fire for each namespace. Useful for:</p>
<ul>
<li>Per-namespace timing</li>
<li>Progress reporting (“Processing namespace 2 of 5”)</li>
<li>Namespace-level metrics</li>
</ul>
<p><strong><code>before_execute_command</code></strong> / <strong><code>after_execute_command</code></strong> - Fire for each command. Useful for:</p>
<ul>
<li>Per-command timing</li>
<li>Detailed execution logging</li>
<li>Command-level metrics</li>
</ul>
<h3 id="completed-phase"><a class="header" href="#completed-phase">Completed Phase</a></h3>
<p>The Completed phase covers results collection.</p>
<pre><code>Pipeline&lt;Completed&gt;::results()
    │
    ├─► on_results_start
    │
    └─► on_results_finish
            │
            ▼
        Results returned
</code></pre>
<p><strong><code>on_results_start</code></strong> - Fires when results collection begins. Useful for:</p>
<ul>
<li>Logging “collecting results”</li>
<li>Preparing result processors</li>
</ul>
<p><strong><code>on_results_finish</code></strong> - Fires when results collection completes. Useful for:</p>
<ul>
<li>Final pipeline metrics</li>
<li>Cleanup operations</li>
<li>Sending “pipeline complete” notifications</li>
</ul>
<h2 id="built-in-implementation-debugeventhooks"><a class="header" href="#built-in-implementation-debugeventhooks">Built-in Implementation: DebugEventHooks</a></h2>
<p>Panopticon includes <code>DebugEventHooks</code> for development:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DebugEventHooks;

#[async_trait]
impl EventHooks for DebugEventHooks {
    async fn after_added_namespace(&amp;self, event: &amp;hook_events::NamespaceInit) -&gt; Result&lt;()&gt; {
        println!("DebugEventHooks - after_added_namespace: {:?}", event);
        Ok(())
    }

    async fn after_added_command(&amp;self, event: &amp;hook_events::CommandInit) -&gt; Result&lt;()&gt; {
        println!("DebugEventHooks - after_added_command: {:?}", event);
        Ok(())
    }

    async fn before_compile_pipeline(&amp;self, event: &amp;hook_events::PipelineInfo) -&gt; Result&lt;()&gt; {
        println!("DebugEventHooks - before_compile_pipeline: {:?}", event);
        Ok(())
    }

    async fn after_compile_pipeline(&amp;self, event: &amp;hook_events::PipelineCompiled) -&gt; Result&lt;()&gt; {
        println!("DebugEventHooks - after_compile_pipeline: {:?}", event);
        Ok(())
    }

    async fn before_execute_pipeline(&amp;self, event: &amp;hook_events::PipelineInfo) -&gt; Result&lt;()&gt; {
        println!("DebugEventHooks - before_execute_pipeline: {:?}", event);
        Ok(())
    }

    async fn after_execute_pipeline(&amp;self, event: &amp;hook_events::PipelineExecuted) -&gt; Result&lt;()&gt; {
        println!("DebugEventHooks - after_execute_pipeline: {:?}", event);
        Ok(())
    }

    async fn before_execute_namespace(&amp;self, event: &amp;hook_events::NamespaceInfo) -&gt; Result&lt;()&gt; {
        println!("DebugEventHooks - before_execute_namespace: {:?}", event);
        Ok(())
    }

    async fn after_execute_namespace(&amp;self, event: &amp;hook_events::NamespaceExecuted) -&gt; Result&lt;()&gt; {
        println!("DebugEventHooks - after_execute_namespace: {:?}", event);
        Ok(())
    }

    async fn before_execute_command(&amp;self, event: &amp;hook_events::CommandInfo) -&gt; Result&lt;()&gt; {
        println!("DebugEventHooks - before_execute_command: {:?}", event);
        Ok(())
    }

    async fn after_execute_command(&amp;self, event: &amp;hook_events::CommandExecuted) -&gt; Result&lt;()&gt; {
        println!("DebugEventHooks - after_execute_command: {:?}", event);
        Ok(())
    }

    async fn on_results_start(&amp;self, event: &amp;hook_events::PipelineInfo) -&gt; Result&lt;()&gt; {
        println!("DebugEventHooks - on_results_start: {:?}", event);
        Ok(())
    }

    async fn on_results_finish(&amp;self, event: &amp;hook_events::PipelineCompleted) -&gt; Result&lt;()&gt; {
        println!("DebugEventHooks - on_results_finish: {:?}", event);
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<p>This is included automatically in debug builds via <code>PipelineServices::defaults()</code>.</p>
<h2 id="example-metrics-hooks"><a class="header" href="#example-metrics-hooks">Example: Metrics Hooks</a></h2>
<p>Collect execution timing metrics:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::prelude::*;
use async_trait::async_trait;
use std::sync::Mutex;
use std::time::Instant;
use std::collections::HashMap;

pub struct MetricsHooks {
    pipeline_start: Mutex&lt;Option&lt;Instant&gt;&gt;,
    namespace_starts: Mutex&lt;HashMap&lt;usize, Instant&gt;&gt;,
    command_starts: Mutex&lt;HashMap&lt;String, Instant&gt;&gt;,
    metrics: Mutex&lt;Metrics&gt;,
}

#[derive(Default)]
pub struct Metrics {
    pub pipeline_duration_ms: u64,
    pub namespace_durations_ms: HashMap&lt;String, u64&gt;,
    pub command_durations_ms: HashMap&lt;String, u64&gt;,
    pub total_commands: usize,
}

impl MetricsHooks {
    pub fn new() -&gt; Self {
        Self {
            pipeline_start: Mutex::new(None),
            namespace_starts: Mutex::new(HashMap::new()),
            command_starts: Mutex::new(HashMap::new()),
            metrics: Mutex::new(Metrics::default()),
        }
    }

    pub fn get_metrics(&amp;self) -&gt; Metrics {
        self.metrics.lock().unwrap().clone()
    }
}

#[async_trait]
impl EventHooks for MetricsHooks {
    async fn before_execute_pipeline(&amp;self, _event: &amp;hook_events::PipelineInfo) -&gt; Result&lt;()&gt; {
        *self.pipeline_start.lock().unwrap() = Some(Instant::now());
        Ok(())
    }

    async fn after_execute_pipeline(&amp;self, _event: &amp;hook_events::PipelineExecuted) -&gt; Result&lt;()&gt; {
        if let Some(start) = *self.pipeline_start.lock().unwrap() {
            self.metrics.lock().unwrap().pipeline_duration_ms =
                start.elapsed().as_millis() as u64;
        }
        Ok(())
    }

    async fn before_execute_namespace(&amp;self, event: &amp;hook_events::NamespaceInfo) -&gt; Result&lt;()&gt; {
        self.namespace_starts
            .lock()
            .unwrap()
            .insert(event.namespace_index, Instant::now());
        Ok(())
    }

    async fn after_execute_namespace(&amp;self, event: &amp;hook_events::NamespaceExecuted) -&gt; Result&lt;()&gt; {
        if let Some(start) = self.namespace_starts.lock().unwrap().get(&amp;event.namespace_index) {
            self.metrics
                .lock()
                .unwrap()
                .namespace_durations_ms
                .insert(event.namespace_name.clone(), start.elapsed().as_millis() as u64);
        }
        Ok(())
    }

    async fn before_execute_command(&amp;self, event: &amp;hook_events::CommandInfo) -&gt; Result&lt;()&gt; {
        self.command_starts
            .lock()
            .unwrap()
            .insert(event.command_name.clone(), Instant::now());
        Ok(())
    }

    async fn after_execute_command(&amp;self, event: &amp;hook_events::CommandExecuted) -&gt; Result&lt;()&gt; {
        let mut metrics = self.metrics.lock().unwrap();
        metrics.total_commands += 1;

        if let Some(start) = self.command_starts.lock().unwrap().get(&amp;event.command_name) {
            metrics
                .command_durations_ms
                .insert(event.command_name.clone(), start.elapsed().as_millis() as u64);
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h2 id="example-progress-hooks"><a class="header" href="#example-progress-hooks">Example: Progress Hooks</a></h2>
<p>Report execution progress to a UI:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::prelude::*;
use async_trait::async_trait;
use tokio::sync::mpsc;

#[derive(Debug, Clone)]
pub enum ProgressEvent {
    PipelineStarted { total_namespaces: usize, total_commands: usize },
    NamespaceStarted { name: String, index: usize, command_count: usize },
    NamespaceFinished { name: String, index: usize },
    CommandStarted { name: String, command_type: String },
    CommandFinished { name: String },
    PipelineFinished,
}

pub struct ProgressHooks {
    sender: mpsc::Sender&lt;ProgressEvent&gt;,
}

impl ProgressHooks {
    pub fn new(sender: mpsc::Sender&lt;ProgressEvent&gt;) -&gt; Self {
        Self { sender }
    }
}

#[async_trait]
impl EventHooks for ProgressHooks {
    async fn before_execute_pipeline(&amp;self, event: &amp;hook_events::PipelineInfo) -&gt; Result&lt;()&gt; {
        let _ = self.sender.send(ProgressEvent::PipelineStarted {
            total_namespaces: event.namespace_count,
            total_commands: event.command_count,
        }).await;
        Ok(())
    }

    async fn after_execute_pipeline(&amp;self, _event: &amp;hook_events::PipelineExecuted) -&gt; Result&lt;()&gt; {
        let _ = self.sender.send(ProgressEvent::PipelineFinished).await;
        Ok(())
    }

    async fn before_execute_namespace(&amp;self, event: &amp;hook_events::NamespaceInfo) -&gt; Result&lt;()&gt; {
        let _ = self.sender.send(ProgressEvent::NamespaceStarted {
            name: event.namespace_name.clone(),
            index: event.namespace_index,
            command_count: event.command_count,
        }).await;
        Ok(())
    }

    async fn after_execute_namespace(&amp;self, event: &amp;hook_events::NamespaceExecuted) -&gt; Result&lt;()&gt; {
        let _ = self.sender.send(ProgressEvent::NamespaceFinished {
            name: event.namespace_name.clone(),
            index: event.namespace_index,
        }).await;
        Ok(())
    }

    async fn before_execute_command(&amp;self, event: &amp;hook_events::CommandInfo) -&gt; Result&lt;()&gt; {
        let _ = self.sender.send(ProgressEvent::CommandStarted {
            name: event.command_name.clone(),
            command_type: event.command_type.clone(),
        }).await;
        Ok(())
    }

    async fn after_execute_command(&amp;self, event: &amp;hook_events::CommandExecuted) -&gt; Result&lt;()&gt; {
        let _ = self.sender.send(ProgressEvent::CommandFinished {
            name: event.command_name.clone(),
        }).await;
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h2 id="example-audit-hooks"><a class="header" href="#example-audit-hooks">Example: Audit Hooks</a></h2>
<p>Record execution history for compliance:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::prelude::*;
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use serde::Serialize;

#[derive(Serialize)]
pub struct AuditRecord {
    timestamp: DateTime&lt;Utc&gt;,
    event_type: String,
    details: serde_json::Value,
}

pub struct AuditHooks {
    records: std::sync::Mutex&lt;Vec&lt;AuditRecord&gt;&gt;,
}

impl AuditHooks {
    pub fn new() -&gt; Self {
        Self {
            records: std::sync::Mutex::new(Vec::new()),
        }
    }

    fn record(&amp;self, event_type: &amp;str, details: serde_json::Value) {
        self.records.lock().unwrap().push(AuditRecord {
            timestamp: Utc::now(),
            event_type: event_type.to_string(),
            details,
        });
    }

    pub fn export(&amp;self) -&gt; Vec&lt;AuditRecord&gt; {
        self.records.lock().unwrap().clone()
    }
}

#[async_trait]
impl EventHooks for AuditHooks {
    async fn before_execute_pipeline(&amp;self, event: &amp;hook_events::PipelineInfo) -&gt; Result&lt;()&gt; {
        self.record("pipeline_started", serde_json::json!({
            "namespace_count": event.namespace_count,
            "command_count": event.command_count,
        }));
        Ok(())
    }

    async fn after_execute_command(&amp;self, event: &amp;hook_events::CommandExecuted) -&gt; Result&lt;()&gt; {
        self.record("command_executed", serde_json::json!({
            "command_name": event.command_name,
            "command_type": event.command_type,
            "namespace_index": event.namespace_index,
        }));
        Ok(())
    }

    async fn on_results_finish(&amp;self, event: &amp;hook_events::PipelineCompleted) -&gt; Result&lt;()&gt; {
        self.record("pipeline_completed", serde_json::json!({
            "namespace_count": event.namespace_count,
            "command_count": event.command_count,
        }));
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>Hook errors are aggregated, not short-circuited. All registered hooks run even if one fails:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// If you have two hooks registered and both fail:
// Hook 1 returns: Err(anyhow!("Database connection failed"))
// Hook 2 returns: Err(anyhow!("Network timeout"))
//
// The combined error is:
// Err(anyhow!("Hook service errors: Database connection failed; Network timeout"))
<span class="boring">}</span></code></pre>
<p>This ensures that one misbehaving hook does not prevent other hooks from executing. However, if any hook fails, the combined error propagates to the caller.</p>
<h3 id="recommended-error-handling-patterns-1"><a class="header" href="#recommended-error-handling-patterns-1">Recommended Error Handling Patterns</a></h3>
<p><strong>Non-critical hooks (logging, metrics):</strong> Handle errors internally:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn after_execute_command(&amp;self, event: &amp;hook_events::CommandExecuted) -&gt; Result&lt;()&gt; {
    if let Err(e) = self.try_log_metrics(event).await {
        eprintln!("Warning: metrics logging failed: {}", e);
    }
    Ok(()) // Don't propagate - metrics failure shouldn't stop execution
}
<span class="boring">}</span></code></pre>
<p><strong>Critical hooks (audit, compliance):</strong> Propagate errors:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn after_execute_command(&amp;self, event: &amp;hook_events::CommandExecuted) -&gt; Result&lt;()&gt; {
    self.write_audit_log(event)
        .await
        .context("Audit logging is required - cannot continue without it")?;
    Ok(())
}
<span class="boring">}</span></code></pre>
<h2 id="registering-hooks"><a class="header" href="#registering-hooks">Registering Hooks</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::prelude::*;

let mut services = PipelineServices::new();

// Register multiple hooks - they all receive events
services.add_hook(MetricsHooks::new());
services.add_hook(AuditHooks::new());
services.add_hook(ProgressHooks::new(progress_sender));

let pipeline = Pipeline::with_services(services);
<span class="boring">}</span></code></pre>
<h2 id="testing-hooks"><a class="header" href="#testing-hooks">Testing Hooks</a></h2>
<p>Create a mock hook that records all events:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};

#[derive(Default, Clone)]
pub struct MockHooks {
    events: Arc&lt;Mutex&lt;Vec&lt;String&gt;&gt;&gt;,
}

impl MockHooks {
    pub fn events(&amp;self) -&gt; Vec&lt;String&gt; {
        self.events.lock().unwrap().clone()
    }
}

#[async_trait]
impl EventHooks for MockHooks {
    async fn before_execute_pipeline(&amp;self, _: &amp;hook_events::PipelineInfo) -&gt; Result&lt;()&gt; {
        self.events.lock().unwrap().push("before_execute_pipeline".into());
        Ok(())
    }

    async fn after_execute_pipeline(&amp;self, _: &amp;hook_events::PipelineExecuted) -&gt; Result&lt;()&gt; {
        self.events.lock().unwrap().push("after_execute_pipeline".into());
        Ok(())
    }

    // ... implement other hooks similarly
}

#[tokio::test]
async fn test_hook_order() {
    let hooks = MockHooks::default();
    let mut services = PipelineServices::new();
    services.add_hook(hooks.clone());

    let mut pipeline = Pipeline::with_services(services);
    // ... add namespaces and commands
    let pipeline = pipeline.compile().unwrap();
    let pipeline = pipeline.execute().await.unwrap();

    let events = hooks.events();
    assert!(events.contains(&amp;"before_execute_pipeline".to_string()));
    assert!(events.contains(&amp;"after_execute_pipeline".to_string()));

    // Verify order
    let before_idx = events.iter().position(|e| e == "before_execute_pipeline").unwrap();
    let after_idx = events.iter().position(|e| e == "after_execute_pipeline").unwrap();
    assert!(before_idx &lt; after_idx);
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="hook-events"><a class="header" href="#hook-events">Hook Events</a></h1>
<p>Hook events are the data structures passed to <code>EventHooks</code> methods. Each event type contains information relevant to its lifecycle point. This page documents all event types and their fields.</p>
<h2 id="event-types-overview"><a class="header" href="#event-types-overview">Event Types Overview</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Event Type</th><th>Used By</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>PipelineInfo</code></td><td><code>before_compile_pipeline</code>, <code>before_execute_pipeline</code>, <code>on_results_start</code></td><td>Basic pipeline statistics</td></tr>
<tr><td><code>PipelineCompiled</code></td><td><code>after_compile_pipeline</code></td><td>Pipeline info with compilation timestamp</td></tr>
<tr><td><code>PipelineExecuted</code></td><td><code>after_execute_pipeline</code></td><td>Pipeline info with execution timestamp</td></tr>
<tr><td><code>PipelineCompleted</code></td><td><code>on_results_finish</code></td><td>Pipeline info with completion timestamp</td></tr>
<tr><td><code>NamespaceInit</code></td><td><code>after_added_namespace</code></td><td>Namespace registration details</td></tr>
<tr><td><code>NamespaceInfo</code></td><td><code>before_execute_namespace</code></td><td>Namespace execution context</td></tr>
<tr><td><code>NamespaceExecuted</code></td><td><code>after_execute_namespace</code></td><td>Namespace completion details</td></tr>
<tr><td><code>CommandInit</code></td><td><code>after_added_command</code></td><td>Command registration details</td></tr>
<tr><td><code>CommandInfo</code></td><td><code>before_execute_command</code></td><td>Command execution context</td></tr>
<tr><td><code>CommandExecuted</code></td><td><code>after_execute_command</code></td><td>Command completion details</td></tr>
</tbody>
</table>
</div>
<h2 id="pipeline-events"><a class="header" href="#pipeline-events">Pipeline Events</a></h2>
<p>These events provide information about the pipeline as a whole.</p>
<h3 id="pipelineinfo"><a class="header" href="#pipelineinfo">PipelineInfo</a></h3>
<p>Basic pipeline statistics, used at multiple lifecycle points.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct PipelineInfo {
    pub namespace_count: usize,
    pub command_count: usize,
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>namespace_count</code></td><td><code>usize</code></td><td>Total number of namespaces in the pipeline</td></tr>
<tr><td><code>command_count</code></td><td><code>usize</code></td><td>Total number of commands across all namespaces</td></tr>
</tbody>
</table>
</div>
<p><strong>Used by:</strong></p>
<ul>
<li><code>before_compile_pipeline</code> - Pipeline structure before validation</li>
<li><code>before_execute_pipeline</code> - Pipeline structure at execution start</li>
<li><code>on_results_start</code> - Pipeline structure when collecting results</li>
</ul>
<p><strong>Example usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn before_execute_pipeline(&amp;self, event: &amp;hook_events::PipelineInfo) -&gt; Result&lt;()&gt; {
    println!(
        "Starting pipeline with {} namespaces and {} commands",
        event.namespace_count,
        event.command_count
    );
    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="pipelinecompiled"><a class="header" href="#pipelinecompiled">PipelineCompiled</a></h3>
<p>Extends <code>PipelineInfo</code> with compilation timing.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct PipelineCompiled {
    pub namespace_count: usize,
    pub command_count: usize,
    pub compiled_at: Instant,
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>namespace_count</code></td><td><code>usize</code></td><td>Total number of namespaces</td></tr>
<tr><td><code>command_count</code></td><td><code>usize</code></td><td>Total number of commands</td></tr>
<tr><td><code>compiled_at</code></td><td><code>Instant</code></td><td>When compilation completed</td></tr>
</tbody>
</table>
</div>
<p><strong>Used by:</strong> <code>after_compile_pipeline</code></p>
<p><strong>Example usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn after_compile_pipeline(&amp;self, event: &amp;hook_events::PipelineCompiled) -&gt; Result&lt;()&gt; {
    println!(
        "Pipeline compiled at {:?} with {} commands ready for execution",
        event.compiled_at,
        event.command_count
    );
    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="pipelineexecuted"><a class="header" href="#pipelineexecuted">PipelineExecuted</a></h3>
<p>Extends <code>PipelineInfo</code> with execution timing.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct PipelineExecuted {
    pub namespace_count: usize,
    pub command_count: usize,
    pub executed_at: Instant,
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>namespace_count</code></td><td><code>usize</code></td><td>Total number of namespaces executed</td></tr>
<tr><td><code>command_count</code></td><td><code>usize</code></td><td>Total number of commands executed</td></tr>
<tr><td><code>executed_at</code></td><td><code>Instant</code></td><td>When execution completed</td></tr>
</tbody>
</table>
</div>
<p><strong>Used by:</strong> <code>after_execute_pipeline</code></p>
<p><strong>Example usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn after_execute_pipeline(&amp;self, event: &amp;hook_events::PipelineExecuted) -&gt; Result&lt;()&gt; {
    let duration = event.executed_at.elapsed();
    println!(
        "Pipeline execution finished. {} commands completed in {:?}",
        event.command_count,
        duration
    );
    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="pipelinecompleted"><a class="header" href="#pipelinecompleted">PipelineCompleted</a></h3>
<p>Extends <code>PipelineInfo</code> with completion timing, marking the end of the pipeline lifecycle.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct PipelineCompleted {
    pub namespace_count: usize,
    pub command_count: usize,
    pub completed_at: Instant,
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>namespace_count</code></td><td><code>usize</code></td><td>Total number of namespaces</td></tr>
<tr><td><code>command_count</code></td><td><code>usize</code></td><td>Total number of commands</td></tr>
<tr><td><code>completed_at</code></td><td><code>Instant</code></td><td>When results collection completed</td></tr>
</tbody>
</table>
</div>
<p><strong>Used by:</strong> <code>on_results_finish</code></p>
<p><strong>Example usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn on_results_finish(&amp;self, event: &amp;hook_events::PipelineCompleted) -&gt; Result&lt;()&gt; {
    println!(
        "Pipeline fully completed at {:?}. All {} commands processed.",
        event.completed_at,
        event.command_count
    );
    Ok(())
}
<span class="boring">}</span></code></pre>
<h2 id="namespace-events"><a class="header" href="#namespace-events">Namespace Events</a></h2>
<p>These events provide information about individual namespaces.</p>
<h3 id="namespaceinit"><a class="header" href="#namespaceinit">NamespaceInit</a></h3>
<p>Information about a namespace when it is added to the pipeline (Draft phase).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct NamespaceInit {
    pub namespace_index: usize,
    pub namespace_name: String,
    pub namespace_type: String,
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>namespace_index</code></td><td><code>usize</code></td><td>Position of this namespace (0-indexed)</td></tr>
<tr><td><code>namespace_name</code></td><td><code>String</code></td><td>Name given to the namespace</td></tr>
<tr><td><code>namespace_type</code></td><td><code>String</code></td><td>Type of namespace (“Once”, “Iterative”, “Static”)</td></tr>
</tbody>
</table>
</div>
<p><strong>Used by:</strong> <code>after_added_namespace</code></p>
<p><strong>Example usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn after_added_namespace(&amp;self, event: &amp;hook_events::NamespaceInit) -&gt; Result&lt;()&gt; {
    println!(
        "Namespace #{} '{}' added (type: {})",
        event.namespace_index,
        event.namespace_name,
        event.namespace_type
    );

    // Validate namespace naming conventions
    if !event.namespace_name.chars().all(|c| c.is_alphanumeric() || c == '_') {
        return Err(anyhow::anyhow!(
            "Namespace name '{}' contains invalid characters",
            event.namespace_name
        ));
    }

    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="namespaceinfo"><a class="header" href="#namespaceinfo">NamespaceInfo</a></h3>
<p>Information about a namespace just before it executes.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct NamespaceInfo {
    pub namespace_index: usize,
    pub namespace_name: String,
    pub command_count: usize,
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>namespace_index</code></td><td><code>usize</code></td><td>Position of this namespace (0-indexed)</td></tr>
<tr><td><code>namespace_name</code></td><td><code>String</code></td><td>Name of the namespace</td></tr>
<tr><td><code>command_count</code></td><td><code>usize</code></td><td>Number of commands in this namespace</td></tr>
</tbody>
</table>
</div>
<p><strong>Used by:</strong> <code>before_execute_namespace</code></p>
<p><strong>Example usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn before_execute_namespace(&amp;self, event: &amp;hook_events::NamespaceInfo) -&gt; Result&lt;()&gt; {
    println!(
        "Executing namespace '{}' ({} commands)",
        event.namespace_name,
        event.command_count
    );
    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="namespaceexecuted"><a class="header" href="#namespaceexecuted">NamespaceExecuted</a></h3>
<p>Information about a namespace after it finishes executing.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct NamespaceExecuted {
    pub namespace_index: usize,
    pub namespace_name: String,
    pub executed_at: Instant,
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>namespace_index</code></td><td><code>usize</code></td><td>Position of this namespace (0-indexed)</td></tr>
<tr><td><code>namespace_name</code></td><td><code>String</code></td><td>Name of the namespace</td></tr>
<tr><td><code>executed_at</code></td><td><code>Instant</code></td><td>When namespace execution completed</td></tr>
</tbody>
</table>
</div>
<p><strong>Used by:</strong> <code>after_execute_namespace</code></p>
<p><strong>Example usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn after_execute_namespace(&amp;self, event: &amp;hook_events::NamespaceExecuted) -&gt; Result&lt;()&gt; {
    println!(
        "Namespace '{}' (index {}) completed execution",
        event.namespace_name,
        event.namespace_index
    );
    Ok(())
}
<span class="boring">}</span></code></pre>
<h2 id="command-events"><a class="header" href="#command-events">Command Events</a></h2>
<p>These events provide information about individual commands.</p>
<h3 id="commandinit"><a class="header" href="#commandinit">CommandInit</a></h3>
<p>Information about a command when it is added to a namespace (Draft phase).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct CommandInit {
    pub namespace_index: usize,
    pub command_name: String,
    pub command_type: String,
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>namespace_index</code></td><td><code>usize</code></td><td>Index of the parent namespace</td></tr>
<tr><td><code>command_name</code></td><td><code>String</code></td><td>Name given to this command</td></tr>
<tr><td><code>command_type</code></td><td><code>String</code></td><td>Type of command (e.g., “FileCommand”, “SqlCommand”)</td></tr>
</tbody>
</table>
</div>
<p><strong>Used by:</strong> <code>after_added_command</code></p>
<p><strong>Example usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn after_added_command(&amp;self, event: &amp;hook_events::CommandInit) -&gt; Result&lt;()&gt; {
    println!(
        "Command '{}' (type: {}) added to namespace #{}",
        event.command_name,
        event.command_type,
        event.namespace_index
    );

    // Track command types for metrics
    self.command_types
        .lock()
        .unwrap()
        .entry(event.command_type.clone())
        .and_modify(|c| *c += 1)
        .or_insert(1);

    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="commandinfo"><a class="header" href="#commandinfo">CommandInfo</a></h3>
<p>Information about a command just before it executes.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct CommandInfo {
    pub namespace_index: usize,
    pub command_name: String,
    pub command_type: String,
    pub command_count: usize,
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>namespace_index</code></td><td><code>usize</code></td><td>Index of the parent namespace</td></tr>
<tr><td><code>command_name</code></td><td><code>String</code></td><td>Name of this command</td></tr>
<tr><td><code>command_type</code></td><td><code>String</code></td><td>Type of command</td></tr>
<tr><td><code>command_count</code></td><td><code>usize</code></td><td>Total commands in the parent namespace</td></tr>
</tbody>
</table>
</div>
<p><strong>Used by:</strong> <code>before_execute_command</code></p>
<p><strong>Example usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn before_execute_command(&amp;self, event: &amp;hook_events::CommandInfo) -&gt; Result&lt;()&gt; {
    println!(
        "Executing '{}' ({}) - command in namespace #{}",
        event.command_name,
        event.command_type,
        event.namespace_index
    );

    // Start timing this command
    self.start_times
        .lock()
        .unwrap()
        .insert(event.command_name.clone(), std::time::Instant::now());

    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="commandexecuted"><a class="header" href="#commandexecuted">CommandExecuted</a></h3>
<p>Information about a command after it finishes executing.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct CommandExecuted {
    pub namespace_index: usize,
    pub command_name: String,
    pub command_type: String,
    pub executed_at: Instant,
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>namespace_index</code></td><td><code>usize</code></td><td>Index of the parent namespace</td></tr>
<tr><td><code>command_name</code></td><td><code>String</code></td><td>Name of this command</td></tr>
<tr><td><code>command_type</code></td><td><code>String</code></td><td>Type of command</td></tr>
<tr><td><code>executed_at</code></td><td><code>Instant</code></td><td>When command execution completed</td></tr>
</tbody>
</table>
</div>
<p><strong>Used by:</strong> <code>after_execute_command</code></p>
<p><strong>Example usage:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn after_execute_command(&amp;self, event: &amp;hook_events::CommandExecuted) -&gt; Result&lt;()&gt; {
    // Calculate duration if we tracked the start time
    if let Some(start) = self.start_times.lock().unwrap().get(&amp;event.command_name) {
        let duration = start.elapsed();
        println!(
            "Command '{}' completed in {:?}",
            event.command_name,
            duration
        );

        // Record metrics
        self.metrics
            .lock()
            .unwrap()
            .command_durations
            .insert(event.command_name.clone(), duration);
    }

    Ok(())
}
<span class="boring">}</span></code></pre>
<h2 id="working-with-instant"><a class="header" href="#working-with-instant">Working with Instant</a></h2>
<p>Several events include an <code>Instant</code> field for timing. Here are common patterns:</p>
<h3 id="calculating-duration"><a class="header" href="#calculating-duration">Calculating Duration</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Instant;

// Store the instant when you receive it
let start = event.compiled_at;

// Later, calculate elapsed time
let duration = start.elapsed();
println!("Time since compilation: {:?}", duration);
<span class="boring">}</span></code></pre>
<h3 id="comparing-instants"><a class="header" href="#comparing-instants">Comparing Instants</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Store instants from before/after hooks
let compile_time = self.compile_instant.lock().unwrap();
let execute_time = event.executed_at;

// Calculate time between events
if let Some(compile) = *compile_time {
    let time_to_execute = execute_time.duration_since(compile);
    println!("Time from compile to execute: {:?}", time_to_execute);
}
<span class="boring">}</span></code></pre>
<h3 id="metrics-collection-pattern"><a class="header" href="#metrics-collection-pattern">Metrics Collection Pattern</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use std::sync::Mutex;
use std::time::{Duration, Instant};

pub struct TimingMetrics {
    compile_start: Mutex&lt;Option&lt;Instant&gt;&gt;,
    execute_start: Mutex&lt;Option&lt;Instant&gt;&gt;,
    namespace_starts: Mutex&lt;HashMap&lt;usize, Instant&gt;&gt;,
    command_starts: Mutex&lt;HashMap&lt;String, Instant&gt;&gt;,

    // Collected metrics
    pub compile_duration: Mutex&lt;Option&lt;Duration&gt;&gt;,
    pub execute_duration: Mutex&lt;Option&lt;Duration&gt;&gt;,
    pub namespace_durations: Mutex&lt;HashMap&lt;String, Duration&gt;&gt;,
    pub command_durations: Mutex&lt;HashMap&lt;String, Duration&gt;&gt;,
}
<span class="boring">}</span></code></pre>
<h2 id="complete-event-flow-example"><a class="header" href="#complete-event-flow-example">Complete Event Flow Example</a></h2>
<p>Here is how events flow through a typical pipeline execution:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pipeline construction (Draft phase)
pipeline.add_namespace("data", NamespaceType::Once);
// → after_added_namespace(NamespaceInit { index: 0, name: "data", type: "Once" })

pipeline.add_command("data", "load", FileCommand::new());
// → after_added_command(CommandInit { namespace_index: 0, name: "load", type: "FileCommand" })

// Compilation
pipeline.compile();
// → before_compile_pipeline(PipelineInfo { namespace_count: 1, command_count: 1 })
// → after_compile_pipeline(PipelineCompiled { namespace_count: 1, command_count: 1, compiled_at: ... })

// Execution (Ready phase)
pipeline.execute().await;
// → before_execute_pipeline(PipelineInfo { namespace_count: 1, command_count: 1 })
//   → before_execute_namespace(NamespaceInfo { index: 0, name: "data", command_count: 1 })
//     → before_execute_command(CommandInfo { namespace_index: 0, name: "load", type: "FileCommand", count: 1 })
//     → after_execute_command(CommandExecuted { namespace_index: 0, name: "load", type: "FileCommand", executed_at: ... })
//   → after_execute_namespace(NamespaceExecuted { index: 0, name: "data", executed_at: ... })
// → after_execute_pipeline(PipelineExecuted { namespace_count: 1, command_count: 1, executed_at: ... })

// Results collection (Completed phase)
pipeline.results();
// → on_results_start(PipelineInfo { namespace_count: 1, command_count: 1 })
// → on_results_finish(PipelineCompleted { namespace_count: 1, command_count: 1, completed_at: ... })
<span class="boring">}</span></code></pre>
<h2 id="importing-event-types"><a class="header" href="#importing-event-types">Importing Event Types</a></h2>
<p>Event types are available through the <code>hook_events</code> module:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::services::hook_events::{
    PipelineInfo,
    PipelineCompiled,
    PipelineExecuted,
    PipelineCompleted,
    NamespaceInit,
    NamespaceInfo,
    NamespaceExecuted,
    CommandInit,
    CommandInfo,
    CommandExecuted,
};
<span class="boring">}</span></code></pre>
<p>Or import the module and use qualified names:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use panopticon_core::services::hook_events;

async fn before_execute_command(&amp;self, event: &amp;hook_events::CommandInfo) -&gt; Result&lt;()&gt; {
    // ...
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="advanced-patterns"><a class="header" href="#advanced-patterns">Advanced Patterns</a></h1>
<p>This section covers expert-level patterns for library extenders who need to push beyond the basics. These patterns emerge from real-world requirements: sharing state across commands, handling dynamic result names safely, and building robust error handling into your commands.</p>
<h2 id="when-you-need-these-patterns"><a class="header" href="#when-you-need-these-patterns">When You Need These Patterns</a></h2>
<p>The patterns in this section solve specific problems:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pattern</th><th>Use When</th></tr>
</thead>
<tbody>
<tr><td><a href="#type-indexed-extensions">Type-Indexed Extensions</a></td><td>Commands need shared state: HTTP clients, database pools, auth tokens</td></tr>
<tr><td><a href="#derived-results">Derived Results</a></td><td>Result names come from user input, not hardcoded strings</td></tr>
<tr><td><a href="#error-handling-3">Error Handling</a></td><td>Building production-quality commands with proper error context</td></tr>
</tbody>
</table>
</div>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Before diving into these patterns, you should be comfortable with:</p>
<ul>
<li>Building custom commands (the three traits: <code>Descriptor</code>, <code>FromAttributes</code>, <code>Executable</code>)</li>
<li>The spec system (<code>CommandSpecBuilder</code>, <code>AttributeSpecBuilder</code>, <code>ObjectFields</code>)</li>
<li>Working with <code>ExecutionContext</code> and <code>InsertBatch</code></li>
</ul>
<p>If any of these feel unfamiliar, review the earlier sections first.</p>
<h2 id="pattern-complexity-vs-necessity"><a class="header" href="#pattern-complexity-vs-necessity">Pattern Complexity vs. Necessity</a></h2>
<p>Not every command needs advanced patterns. Consider the tradeoffs:</p>
<pre><code class="language-text">Simple Command (hardcoded results, no shared state):
  └── Use fixed_result(), implement the three traits, done.

Medium Complexity (dynamic iteration, basic error handling):
  └── Use array_of_objects with derived_result(), add context() to errors.

Complex Command (shared HTTP client, auth tokens, robust errors):
  └── Use Extensions for state, LiteralFieldRef for safety, full anyhow patterns.
</code></pre>
<h2 id="the-extension-ecosystem"><a class="header" href="#the-extension-ecosystem">The Extension Ecosystem</a></h2>
<p>These patterns work together. A real-world API integration command might use all three:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Type-indexed extension: shared HTTP client
let client = context.extensions()
    .read().await
    .get::&lt;reqwest::Client&gt;()
    .cloned()
    .ok_or_else(|| anyhow::anyhow!("HTTP client not configured"))?;  // Error handling

// Derived results: endpoint names from user config
.derived_result("endpoints", name_ref, None, ResultKind::Data)  // Safe via LiteralFieldRef
<span class="boring">}</span></code></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What’s Next</a></h2>
<p>Start with whichever pattern matches your immediate need:</p>
<ol>
<li>
<p><strong><a href="#type-indexed-extensions">Type-Indexed Extensions</a></strong> - If you need to share expensive resources (clients, connections, tokens) across commands without global state.</p>
</li>
<li>
<p><strong><a href="#derived-results">Derived Results</a></strong> - If your command produces results whose names aren’t known until the user provides configuration.</p>
</li>
<li>
<p><strong><a href="#error-handling-3">Error Handling</a></strong> - If you want to understand the error patterns used throughout Panopticon’s built-in commands.</p>
</li>
</ol>
<p>Each section includes real-world examples, anti-patterns to avoid, and guidance on when the pattern is (and isn’t) appropriate.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-indexed-extensions"><a class="header" href="#type-indexed-extensions">Type-Indexed Extensions</a></h1>
<p>The <code>Extensions</code> type provides type-safe storage for shared state that commands can access during execution. It uses Rust’s <code>TypeId</code> system to create a map where each type can have exactly one value, eliminating the need for string keys or global statics.</p>
<h2 id="the-problem-extensions-solve"><a class="header" href="#the-problem-extensions-solve">The Problem Extensions Solve</a></h2>
<p>Consider an API integration that needs to:</p>
<ol>
<li>Make HTTP requests (requires a configured client)</li>
<li>Authenticate requests (requires access tokens)</li>
<li>Handle rate limiting (requires shared state across commands)</li>
</ol>
<p>Without Extensions, you face awkward choices:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Anti-pattern: Global static (not Send + Sync friendly, initialization order issues)
static HTTP_CLIENT: Lazy&lt;reqwest::Client&gt; = Lazy::new(|| { ... });

// Anti-pattern: Pass through every function signature
async fn execute(&amp;self, ctx: &amp;ExecutionContext, client: &amp;Client, token: &amp;str) -&gt; Result&lt;()&gt;

// Anti-pattern: Environment variables for everything
let token = std::env::var("API_TOKEN")?;
<span class="boring">}</span></code></pre>
<p>Extensions solve this by providing a type-indexed container that travels with the <code>ExecutionContext</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// At pipeline setup
extensions.write().await.insert(MyHttpClient::new()?);
extensions.write().await.insert(AuthToken("bearer xyz".into()));

// In any command's execute()
let client = context.extensions()
    .read().await
    .get::&lt;MyHttpClient&gt;()
    .ok_or_else(|| anyhow::anyhow!("HTTP client not configured"))?;
<span class="boring">}</span></code></pre>
<h2 id="how-extensions-works"><a class="header" href="#how-extensions-works">How Extensions Works</a></h2>
<p>Extensions is built on <code>std::any::TypeId</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Extensions {
    map: Arc&lt;RwLock&lt;HashMap&lt;TypeId, Box&lt;dyn Any + Send + Sync&gt;&gt;&gt;&gt;,
}
<span class="boring">}</span></code></pre>
<p>When you insert a value, its type becomes the key:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// These are stored under different keys (TypeId::of::&lt;T&gt;())
extensions.insert(reqwest::Client::new());     // Key: TypeId of reqwest::Client
extensions.insert(AuthToken("...".into()));    // Key: TypeId of AuthToken
extensions.insert(RateLimiter::new(100));      // Key: TypeId of RateLimiter
<span class="boring">}</span></code></pre>
<p>Retrieval is type-safe - you get back exactly what you put in:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let client: Option&lt;&amp;reqwest::Client&gt; = extensions.get::&lt;reqwest::Client&gt;();
let token: Option&lt;&amp;AuthToken&gt; = extensions.get::&lt;AuthToken&gt;();
<span class="boring">}</span></code></pre>
<h2 id="the-default-cancellationtoken"><a class="header" href="#the-default-cancellationtoken">The Default CancellationToken</a></h2>
<p>Every <code>Extensions</code> instance is created with a default <code>tokio_util::sync::CancellationToken</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Default for Extensions {
    fn default() -&gt; Self {
        let mut map = HashMap::new();
        map.insert(
            TypeId::of::&lt;tokio_util::sync::CancellationToken&gt;(),
            Box::new(tokio_util::sync::CancellationToken::new()) as Box&lt;dyn Any + Send + Sync&gt;,
        );
        // ...
    }
}
<span class="boring">}</span></code></pre>
<p>This token enables cooperative cancellation across long-running pipelines. Commands can check it periodically:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn execute(&amp;self, context: &amp;ExecutionContext, output_prefix: &amp;StorePath) -&gt; Result&lt;()&gt; {
    for item in &amp;self.large_dataset {
        // Check for cancellation between iterations
        if context.extensions().is_canceled().await {
            return Err(anyhow::anyhow!("Operation cancelled"));
        }
        process_item(item).await?;
    }
    Ok(())
}
<span class="boring">}</span></code></pre>
<p>The orchestrator can trigger cancellation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From pipeline control code
extensions.cancel().await;
<span class="boring">}</span></code></pre>
<h2 id="using-extensions-in-commands"><a class="header" href="#using-extensions-in-commands">Using Extensions in Commands</a></h2>
<h3 id="reading-extensions"><a class="header" href="#reading-extensions">Reading Extensions</a></h3>
<p>Use <code>read()</code> for shared access (multiple readers allowed):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
impl Executable for MyApiCommand {
    async fn execute(&amp;self, context: &amp;ExecutionContext, output_prefix: &amp;StorePath) -&gt; Result&lt;()&gt; {
        // Acquire read lock
        let ext = context.extensions().read().await;

        // Get typed reference
        let client = ext.get::&lt;reqwest::Client&gt;()
            .ok_or_else(|| anyhow::anyhow!("reqwest::Client not found in extensions"))?;

        // Use the client (lock is held for the scope of `ext`)
        let response = client.get(&amp;self.url).send().await?;

        // Lock released when `ext` goes out of scope
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="writing-extensions"><a class="header" href="#writing-extensions">Writing Extensions</a></h3>
<p>Use <code>write()</code> when you need to modify the extensions (exclusive access):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn refresh_token_if_expired(extensions: &amp;Extensions) -&gt; Result&lt;()&gt; {
    let mut ext = extensions.write().await;

    // Check current token
    let current = ext.get::&lt;AuthToken&gt;();
    if current.map(|t| t.is_expired()).unwrap_or(true) {
        // Remove old token
        ext.remove::&lt;AuthToken&gt;();

        // Insert new token
        let new_token = fetch_new_token().await?;
        ext.insert(new_token);
    }

    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="checking-existence"><a class="header" href="#checking-existence">Checking Existence</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ext = context.extensions().read().await;

if ext.contains::&lt;DatabasePool&gt;() {
    // Use database
} else {
    // Fall back to file-based storage
}
<span class="boring">}</span></code></pre>
<h2 id="real-world-use-cases"><a class="header" href="#real-world-use-cases">Real-World Use Cases</a></h2>
<h3 id="http-client-with-retry-policy"><a class="header" href="#http-client-with-retry-policy">HTTP Client with Retry Policy</a></h3>
<p>Wrap the client in a newtype to configure it once:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ConfiguredClient(reqwest::Client);

impl ConfiguredClient {
    pub fn new(timeout: Duration, max_retries: u32) -&gt; Result&lt;Self&gt; {
        let client = reqwest::Client::builder()
            .timeout(timeout)
            .build()?;
        Ok(Self(client))
    }

    pub fn inner(&amp;self) -&gt; &amp;reqwest::Client {
        &amp;self.0
    }
}

// At setup
extensions.write().await.insert(
    ConfiguredClient::new(Duration::from_secs(30), 3)?
);

// In commands
let client = ext.get::&lt;ConfiguredClient&gt;()
    .ok_or_else(|| anyhow::anyhow!("ConfiguredClient not in extensions"))?
    .inner();
<span class="boring">}</span></code></pre>
<h3 id="database-connection-pool"><a class="header" href="#database-connection-pool">Database Connection Pool</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DbPool(sqlx::PgPool);

impl DbPool {
    pub async fn connect(url: &amp;str) -&gt; Result&lt;Self&gt; {
        let pool = sqlx::PgPool::connect(url).await?;
        Ok(Self(pool))
    }

    pub fn pool(&amp;self) -&gt; &amp;sqlx::PgPool {
        &amp;self.0
    }
}

// Commands can share the pool
let pool = ext.get::&lt;DbPool&gt;()
    .ok_or_else(|| anyhow::anyhow!("Database pool not configured"))?
    .pool();

let rows = sqlx::query("SELECT * FROM users")
    .fetch_all(pool)
    .await?;
<span class="boring">}</span></code></pre>
<h3 id="authentication-tokens"><a class="header" href="#authentication-tokens">Authentication Tokens</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
pub struct BearerToken {
    token: String,
    expires_at: chrono::DateTime&lt;chrono::Utc&gt;,
}

impl BearerToken {
    pub fn is_expired(&amp;self) -&gt; bool {
        chrono::Utc::now() &gt;= self.expires_at
    }

    pub fn header_value(&amp;self) -&gt; String {
        format!("Bearer {}", self.token)
    }
}

// In command
let token = ext.get::&lt;BearerToken&gt;()
    .ok_or_else(|| anyhow::anyhow!("Authentication token not configured"))?;

if token.is_expired() {
    return Err(anyhow::anyhow!("Authentication token has expired"));
}

let response = client
    .get(&amp;url)
    .header("Authorization", token.header_value())
    .send()
    .await?;
<span class="boring">}</span></code></pre>
<h2 id="anti-patterns"><a class="header" href="#anti-patterns">Anti-Patterns</a></h2>
<h3 id="using-string-keys"><a class="header" href="#using-string-keys">Using String Keys</a></h3>
<p>Do not try to implement your own string-keyed map:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WRONG: Loses type safety
struct StringKeyedExtensions(HashMap&lt;String, Box&lt;dyn Any + Send + Sync&gt;&gt;);

extensions.insert("client", Box::new(client));
let client = extensions.get("client").downcast_ref::&lt;???&gt;();  // What type?
<span class="boring">}</span></code></pre>
<p>The type-indexed approach means the type itself is the key - you cannot request the wrong type.</p>
<h3 id="holding-locks-across-await-points"><a class="header" href="#holding-locks-across-await-points">Holding Locks Across Await Points</a></h3>
<p>Be careful with lock scope:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// PROBLEMATIC: Lock held across network call
let ext = context.extensions().read().await;
let client = ext.get::&lt;Client&gt;().unwrap();
let response = client.get(&amp;url).send().await?;  // Lock still held!
drop(ext);

// BETTER: Clone what you need, release lock quickly
let client = {
    let ext = context.extensions().read().await;
    ext.get::&lt;Client&gt;().cloned()
        .ok_or_else(|| anyhow::anyhow!("Client not found"))?
};
// Lock released, now make the network call
let response = client.get(&amp;url).send().await?;
<span class="boring">}</span></code></pre>
<h3 id="one-type-multiple-instances"><a class="header" href="#one-type-multiple-instances">One Type, Multiple Instances</a></h3>
<p>Extensions stores <strong>one value per type</strong>. If you need multiple instances, wrap them:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WRONG: Second insert overwrites first
extensions.insert(Client::new("api1.example.com"));
extensions.insert(Client::new("api2.example.com"));  // Overwrites!

// RIGHT: Use newtypes
struct Api1Client(Client);
struct Api2Client(Client);

extensions.insert(Api1Client(Client::new("api1.example.com")));
extensions.insert(Api2Client(Client::new("api2.example.com")));
<span class="boring">}</span></code></pre>
<p>Or use a collection:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ApiClients(HashMap&lt;String, Client&gt;);

extensions.insert(ApiClients(hashmap! {
    "api1".into() =&gt; Client::new("api1.example.com"),
    "api2".into() =&gt; Client::new("api2.example.com"),
}));
<span class="boring">}</span></code></pre>
<h2 id="when-not-to-use-extensions"><a class="header" href="#when-not-to-use-extensions">When Not to Use Extensions</a></h2>
<p>Extensions are for <strong>shared, long-lived state</strong>. They’re not appropriate for:</p>
<ul>
<li><strong>Per-command configuration</strong>: Use attributes instead</li>
<li><strong>Data flowing through the pipeline</strong>: Use the tabular/scalar stores</li>
<li><strong>Temporary computation state</strong>: Use local variables in <code>execute()</code></li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WRONG: This is per-command config, use an attribute
extensions.insert(OutputFormat::Json);

// WRONG: This is pipeline data, use the store
extensions.insert(UserList(users));

// RIGHT: Shared infrastructure
extensions.insert(HttpClient::new());
extensions.insert(AuthToken::from_env()?);
<span class="boring">}</span></code></pre>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<ul>
<li>Extensions provide type-indexed storage for shared state across commands</li>
<li>Use <code>read()</code> for shared access, <code>write()</code> for mutations</li>
<li>Every Extensions instance includes a default <code>CancellationToken</code></li>
<li>Clone values when you need to release locks before async operations</li>
<li>Use newtypes to store multiple instances of the same underlying type</li>
<li>Reserve Extensions for infrastructure (clients, pools, tokens), not data</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="derived-results"><a class="header" href="#derived-results">Derived Results</a></h1>
<p>Derived results solve a specific problem: what happens when result names aren’t known at compile time, but come from user-provided attribute values? Panopticon uses the <code>LiteralFieldRef</code> type to make this pattern safe at the type level.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>Consider a file loading command where users specify which files to load:</p>
<pre><code class="language-yaml">files:
  - name: users
    file: data/users.csv
  - name: orders
    file: data/orders.csv
</code></pre>
<p>The command should produce results named after each file: <code>users.data</code>, <code>users.rows</code>, <code>orders.data</code>, <code>orders.rows</code>. But these names come from user input - they’re not hardcoded in the schema.</p>
<p>The danger is allowing arbitrary strings as result names. What if someone uses a Tera template?</p>
<pre><code class="language-yaml">files:
  - name: "{{ user_input }}"  # Could be anything at runtime!
    file: data/malicious.csv
</code></pre>
<p>If <code>user_input</code> resolves to something unexpected, the result name becomes unpredictable, breaking downstream dependencies.</p>
<h2 id="the-solution-literalfieldref"><a class="header" href="#the-solution-literalfieldref">The Solution: LiteralFieldRef</a></h2>
<p>Panopticon distinguishes between two kinds of fields in <code>ObjectFields</code>:</p>
<ol>
<li><strong>Literal fields</strong> - Values are used as-is, never processed through Tera</li>
<li><strong>Template fields</strong> - Values support Tera substitution at runtime</li>
</ol>
<p>Only literal fields can provide result names. The type system enforces this:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// add_literal returns (ObjectFields, LiteralFieldRef)
let (fields, name_ref) = fields.add_literal(
    "name",
    TypeDef::Scalar(ScalarType::String),
    true,
    Some("Identifier for this item"),
);

// add_template returns just ObjectFields (no LiteralFieldRef)
let fields = fields.add_template(
    "file",
    TypeDef::Scalar(ScalarType::String),
    true,
    Some("Path to file (supports Tera)"),
    ReferenceKind::StaticTeraTemplate,
);
<span class="boring">}</span></code></pre>
<p>When you call <code>derived_result()</code>, you must provide a <code>LiteralFieldRef</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.derived_result("files", name_ref, Some(TypeDef::Tabular), ResultKind::Data)
<span class="boring">}</span></code></pre>
<p>Since <code>LiteralFieldRef</code> can only come from <code>add_literal()</code>, the compiler guarantees that result names come from literal (non-template) fields.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<p>The <code>LiteralFieldRef</code> is a simple wrapper that carries the field name:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LiteralFieldRef&lt;T&gt; {
    name: T,
}

impl&lt;T&gt; LiteralFieldRef&lt;T&gt; {
    pub fn name(&amp;self) -&gt; &amp;T {
        &amp;self.name
    }
}
<span class="boring">}</span></code></pre>
<p>The key is that <code>ObjectFields::add_literal()</code> is the <strong>only way</strong> to create a <code>LiteralFieldRef</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Into&lt;String&gt; + Clone&gt; ObjectFields&lt;T&gt; {
    // Returns a LiteralFieldRef - can be used for derived results
    pub fn add_literal(
        self,
        name: T,
        ty: TypeDef&lt;T&gt;,
        required: bool,
        hint: Option&lt;T&gt;,
    ) -&gt; (Self, LiteralFieldRef&lt;T&gt;) {
        // ... creates and returns LiteralFieldRef
    }

    // Does NOT return a LiteralFieldRef - cannot be used for derived results
    pub fn add_template(
        self,
        name: T,
        ty: TypeDef&lt;T&gt;,
        required: bool,
        hint: Option&lt;T&gt;,
        reference_kind: ReferenceKind,
    ) -&gt; Self {
        // ... no LiteralFieldRef created
    }
}
<span class="boring">}</span></code></pre>
<h2 id="complete-example-filecommand"><a class="header" href="#complete-example-filecommand">Complete Example: FileCommand</a></h2>
<p>Here’s how the built-in <code>FileCommand</code> uses this pattern:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static FILECOMMAND_SPEC: CommandSchema = LazyLock::new(|| {
    let (pending, fields) = CommandSpecBuilder::new().array_of_objects(
        "files",
        true,
        Some("Array of {name, file, format} objects to read"),
    );

    // "name" is literal - yields LiteralFieldRef
    let (fields, name_ref) = fields.add_literal(
        "name",
        TypeDef::Scalar(ScalarType::String),
        true,
        Some("Identifier for this file in the TabularStore"),
    );

    // "file" is a template - no LiteralFieldRef (paths can use Tera)
    let fields = fields.add_template(
        "file",
        TypeDef::Scalar(ScalarType::String),
        true,
        Some("Path to the file to read (supports tera templates)"),
        ReferenceKind::StaticTeraTemplate,
    );

    // "format" is also a template
    let fields = fields.add_template(
        "format",
        TypeDef::Scalar(ScalarType::String),
        true,
        Some("Format of the file: csv, json, or parquet"),
        ReferenceKind::StaticTeraTemplate,
    );

    pending
        .finalise_attribute(fields)
        .fixed_result("count", TypeDef::Scalar(ScalarType::Number), Some("Number of files loaded"), ResultKind::Meta)
        .fixed_result("total_rows", TypeDef::Scalar(ScalarType::Number), Some("Total rows across files"), ResultKind::Meta)
        // Derived results use name_ref - each file's name becomes a result prefix
        .derived_result("files", name_ref, Some(TypeDef::Tabular), ResultKind::Data)
        .build()
});
<span class="boring">}</span></code></pre>
<p>With this configuration:</p>
<pre><code class="language-yaml">files:
  - name: users
    file: "{{ data_dir }}/users.csv"  # Template - resolved at runtime
    format: csv
  - name: orders
    file: "{{ data_dir }}/orders.csv"
    format: csv
</code></pre>
<p>The results are:</p>
<ul>
<li><code>load.count</code> (fixed)</li>
<li><code>load.total_rows</code> (fixed)</li>
<li><code>load.users.data</code> (derived from literal “users”)</li>
<li><code>load.orders.data</code> (derived from literal “orders”)</li>
</ul>
<p>The <code>file</code> paths can use Tera templates, but <code>name</code> values are used exactly as written.</p>
<h2 id="builder-validation"><a class="header" href="#builder-validation">Builder Validation</a></h2>
<p>The <code>CommandSpecBuilder::build()</code> method validates derived results at initialization:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn build(self) -&gt; (Vec&lt;AttributeSpec&lt;T&gt;&gt;, Vec&lt;ResultSpec&lt;T&gt;&gt;) {
    for result in &amp;self.results {
        if let ResultSpec::DerivedFromSingleAttribute { attribute, name_field, .. } = result {
            // 1. Verify the referenced attribute exists
            let attr = self.attributes.iter()
                .find(|a| &amp;a.name == attribute)
                .unwrap_or_else(|| panic!(
                    "Derived result references unknown attribute '{:?}'",
                    attribute
                ));

            // 2. Verify the attribute is ArrayOf(ObjectOf)
            let fields = extract_object_fields(&amp;attr.ty)
                .unwrap_or_else(|| panic!(
                    "Derived result attribute '{:?}' must be ArrayOf(ObjectOf)",
                    attribute
                ));

            // 3. Verify the name field exists in those fields
            let field_name = name_field.name();
            assert!(
                fields.iter().any(|f| &amp;f.name == field_name),
                "Derived result name_field '{:?}' not found in attribute fields",
                field_name,
            );
        }
    }
    // ...
}
<span class="boring">}</span></code></pre>
<p>This catches misconfigurations early:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// PANIC: "nonexistent" doesn't match any attribute
.derived_result("nonexistent", name_ref, None, ResultKind::Data)

// PANIC: "scalar_attr" is not ArrayOf(ObjectOf)
.attribute(AttributeSpecBuilder::new("scalar_attr", TypeDef::Scalar(ScalarType::String)).build())
.derived_result("scalar_attr", name_ref, None, ResultKind::Data)
<span class="boring">}</span></code></pre>
<h2 id="mixed-literal-and-template-fields"><a class="header" href="#mixed-literal-and-template-fields">Mixed Literal and Template Fields</a></h2>
<p>A single <code>ObjectFields</code> can contain both types of fields:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (pending, fields) = CommandSpecBuilder::new().array_of_objects(
    "transforms",
    true,
    Some("Array of transform specifications"),
);

// Literal: safe for result names
let (fields, name_ref) = fields.add_literal(
    "name",
    TypeDef::Scalar(ScalarType::String),
    true,
    Some("Transform identifier"),
);

// Template: supports Tera substitution
let fields = fields.add_template(
    "expression",
    TypeDef::Scalar(ScalarType::String),
    true,
    Some("Tera expression to evaluate"),
    ReferenceKind::StaticTeraTemplate,
);

// Another literal
let (fields, desc_ref) = fields.add_literal(
    "description",
    TypeDef::Scalar(ScalarType::String),
    false,
    Some("Human-readable description"),
);

// Can use name_ref or desc_ref for derived results (both are literals)
// Cannot use expression (it's a template - no LiteralFieldRef exists)
<span class="boring">}</span></code></pre>
<h2 id="anti-patterns-1"><a class="header" href="#anti-patterns-1">Anti-Patterns</a></h2>
<h3 id="trying-to-use-template-fields-for-derived-results"><a class="header" href="#trying-to-use-template-fields-for-derived-results">Trying to Use Template Fields for Derived Results</a></h3>
<p>This won’t compile - there’s no <code>LiteralFieldRef</code> for template fields:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (pending, fields) = CommandSpecBuilder::new()
    .array_of_objects("items", true, None);

// Only literal fields return LiteralFieldRef
let (fields, name_ref) = fields.add_literal("name", TypeDef::Scalar(ScalarType::String), true, None);

// Template field - no ref returned
let fields = fields.add_template("dynamic_name", TypeDef::Scalar(ScalarType::String), true, None, ReferenceKind::StaticTeraTemplate);

// This won't compile - there's no LiteralFieldRef for "dynamic_name"
// .derived_result("items", ???, None, ResultKind::Data)
<span class="boring">}</span></code></pre>
<h3 id="mismatched-attribute-names"><a class="header" href="#mismatched-attribute-names">Mismatched Attribute Names</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (pending, fields) = CommandSpecBuilder::new()
    .array_of_objects("things", true, None);
let (fields, name_ref) = fields.add_literal("name", TypeDef::Scalar(ScalarType::String), true, None);

pending
    .finalise_attribute(fields)
    // PANIC at build(): "items" doesn't exist, the attribute is named "things"
    .derived_result("items", name_ref, None, ResultKind::Data)
    .build();
<span class="boring">}</span></code></pre>
<h3 id="using-derived-results-with-non-array-attributes"><a class="header" href="#using-derived-results-with-non-array-attributes">Using Derived Results with Non-Array Attributes</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (pending, fields) = CommandSpecBuilder::new()
    .array_of_objects("valid_array", true, None);
let (fields, name_ref) = fields.add_literal("name", TypeDef::Scalar(ScalarType::String), true, None);

pending
    .finalise_attribute(fields)
    // Add a scalar attribute
    .attribute(
        AttributeSpecBuilder::new("scalar_attr", TypeDef::Scalar(ScalarType::String))
            .required()
            .build(),
    )
    // PANIC: scalar_attr is not ArrayOf(ObjectOf)
    .derived_result("scalar_attr", name_ref, None, ResultKind::Data)
    .build();
<span class="boring">}</span></code></pre>
<h2 id="when-to-use-derived-results"><a class="header" href="#when-to-use-derived-results">When to Use Derived Results</a></h2>
<p>Use derived results when:</p>
<ul>
<li>Users provide an array of named items</li>
<li>Each item should produce its own namespaced results</li>
<li>The item names are known at configuration time (not computed at runtime)</li>
</ul>
<p>Examples:</p>
<ul>
<li><strong>FileCommand</strong>: Each file has a name, produces <code>{name}.data</code>, <code>{name}.rows</code></li>
<li><strong>AggregateCommand</strong>: Each aggregation has a name, produces <code>{name}</code> scalar result</li>
<li><strong>ApiCommand</strong>: Each endpoint has a name, produces <code>{name}.response</code>, <code>{name}.status</code></li>
</ul>
<p>Do not use derived results when:</p>
<ul>
<li>Result names are truly fixed (use <code>fixed_result()</code>)</li>
<li>Names need to be computed at runtime (reconsider your design)</li>
<li>You have a single item, not an array (use <code>fixed_result()</code>)</li>
</ul>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<ul>
<li><code>LiteralFieldRef</code> is the compile-time proof that a field is literal (not a template)</li>
<li>Only <code>add_literal()</code> returns a <code>LiteralFieldRef</code>; <code>add_template()</code> does not</li>
<li><code>derived_result()</code> requires a <code>LiteralFieldRef</code>, enforcing safety at the type level</li>
<li>Builder validation catches misconfigurations (wrong attribute name, wrong type) early</li>
<li>Use derived results for user-provided arrays where each item produces named results</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h1>
<p>Panopticon uses <code>anyhow::Result</code> throughout for flexible error handling. This section covers the error patterns used in built-in commands and best practices for your own implementations.</p>
<h2 id="the-anyhow-approach"><a class="header" href="#the-anyhow-approach">The anyhow Approach</a></h2>
<p>All command methods return <code>anyhow::Result&lt;T&gt;</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FromAttributes for MyCommand {
    fn from_attributes(attrs: &amp;Attributes) -&gt; Result&lt;Self&gt; { ... }
}

#[async_trait]
impl Executable for MyCommand {
    async fn execute(&amp;self, context: &amp;ExecutionContext, output_prefix: &amp;StorePath) -&gt; Result&lt;()&gt; { ... }
}
<span class="boring">}</span></code></pre>
<p>This provides:</p>
<ul>
<li><strong>Flexible error types</strong>: Any error implementing <code>std::error::Error</code> can be returned</li>
<li><strong>Context chaining</strong>: Add context to errors as they propagate up</li>
<li><strong>Formatted messages</strong>: Rich error messages with <code>anyhow::anyhow!()</code> macro</li>
<li><strong>Downcasting</strong>: Callers can extract specific error types if needed</li>
</ul>
<h2 id="error-patterns-from-built-in-commands"><a class="header" href="#error-patterns-from-built-in-commands">Error Patterns from Built-in Commands</a></h2>
<h3 id="pattern-1-early-validation-with-clear-messages"><a class="header" href="#pattern-1-early-validation-with-clear-messages">Pattern 1: Early Validation with Clear Messages</a></h3>
<p>Check preconditions early and fail with descriptive messages:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From FileCommand
if !file_spec.file.exists() {
    tracing::warn!(missing_file = %file_spec.file.display(), "File does not exist");
    return Err(anyhow::anyhow!(
        "File does not exist: {}",
        file_spec.file.display()
    ));
}

if file_spec.file.is_dir() {
    tracing::warn!(directory_path = %file_spec.file.display(), "Path is a directory, not a file");
    return Err(anyhow::anyhow!(
        "Path is a directory, not a file: {}",
        file_spec.file.display()
    ));
}
<span class="boring">}</span></code></pre>
<p>Key points:</p>
<ul>
<li>Log with <code>tracing</code> before returning (helps with debugging)</li>
<li>Include the problematic value in the error message</li>
<li>Check multiple conditions separately for specific error messages</li>
</ul>
<h3 id="pattern-2-using-context-for-error-chains"><a class="header" href="#pattern-2-using-context-for-error-chains">Pattern 2: Using context() for Error Chains</a></h3>
<p>The <code>context()</code> method adds information as errors propagate:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From FileCommand::from_attributes
let name = file_obj
    .get_required_string("name")
    .context(format!("files[{}]", i))?;

let file = file_obj
    .get_required_string("file")
    .context(format!("files[{}]", i))?;
<span class="boring">}</span></code></pre>
<p>This produces error chains like:</p>
<pre><code>Error: files[2]

Caused by:
    required field 'file' is missing
</code></pre>
<p>Use <code>context()</code> when:</p>
<ul>
<li>Processing arrays (add the index)</li>
<li>Nested operations (add the parent context)</li>
<li>The underlying error lacks location information</li>
</ul>
<h3 id="pattern-3-converting-external-errors"><a class="header" href="#pattern-3-converting-external-errors">Pattern 3: Converting External Errors</a></h3>
<p>When calling external libraries, convert their errors with context:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From FileCommand
polars::prelude::CsvReadOptions::default()
    .try_into_reader_with_file_path(Some(path.clone()))?
    .finish()
    .map_err(|e| {
        anyhow::anyhow!("Failed to read CSV file {}: {}", path.display(), e)
    })?

// From SqlCommand
let lazy_result = match sql_ctx.execute(&amp;query) {
    Ok(lazy_df) =&gt; lazy_df,
    Err(e) =&gt; {
        tracing::warn!(query = %query, "SQL execution error");
        return Err(anyhow::anyhow!("SQL execution failed: {}", e));
    }
};
<span class="boring">}</span></code></pre>
<p>Choose between <code>map_err</code> and <code>match</code>:</p>
<ul>
<li>Use <code>map_err</code> for simple conversions</li>
<li>Use <code>match</code> when you need to log or perform additional actions on error</li>
</ul>
<h3 id="pattern-4-missing-required-data"><a class="header" href="#pattern-4-missing-required-data">Pattern 4: Missing Required Data</a></h3>
<p>When data should exist but doesn’t:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From SqlCommand
let df = context.tabular().get(&amp;source_path).await?.ok_or_else(|| {
    anyhow::anyhow!("Table source '{}' not found in tabular store", table.source)
})?;

// From AggregateCommand
let col_name = agg.column.as_ref().ok_or_else(|| {
    anyhow::anyhow!("Aggregation '{}': n_unique requires a column", agg.name)
})?;
<span class="boring">}</span></code></pre>
<p>The pattern: <code>option.ok_or_else(|| anyhow::anyhow!(...))?</code></p>
<p>Include enough context to identify:</p>
<ul>
<li>What was being looked for</li>
<li>Where it was expected</li>
<li>Why it matters</li>
</ul>
<h3 id="pattern-5-async-task-errors"><a class="header" href="#pattern-5-async-task-errors">Pattern 5: Async Task Errors</a></h3>
<p>When spawning blocking tasks:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From FileCommand
let df = tokio::task::spawn_blocking(move || -&gt; Result&lt;polars::prelude::DataFrame&gt; {
    // ... blocking work that returns Result
})
.await
.map_err(|e| anyhow::anyhow!("Task join error: {}", e))??;
<span class="boring">}</span></code></pre>
<p>Note the double <code>?</code>:</p>
<ol>
<li>First <code>?</code> handles the <code>JoinError</code> (task panicked or was cancelled)</li>
<li>Second <code>?</code> handles the <code>Result</code> returned by the closure</li>
</ol>
<h3 id="pattern-6-mutually-exclusive-options"><a class="header" href="#pattern-6-mutually-exclusive-options">Pattern 6: Mutually Exclusive Options</a></h3>
<p>When attributes are mutually exclusive:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From TemplateCommand
match (content, file) {
    (Some(content), None) =&gt; {
        templates.push(TemplateSource::Raw { name, content });
    }
    (None, Some(file)) =&gt; {
        templates.push(TemplateSource::File { name, path: PathBuf::from(file) });
    }
    (Some(_), Some(_)) =&gt; {
        return Err(anyhow::anyhow!(
            "templates[{}]: 'content' and 'file' are mutually exclusive",
            i
        ));
    }
    (None, None) =&gt; {
        return Err(anyhow::anyhow!(
            "templates[{}]: must specify either 'content' or 'file'",
            i
        ));
    }
}
<span class="boring">}</span></code></pre>
<p>Handle all cases explicitly for clear error messages.</p>
<h3 id="pattern-7-validation-with-detailed-context"><a class="header" href="#pattern-7-validation-with-detailed-context">Pattern 7: Validation with Detailed Context</a></h3>
<p>Aggregate errors with operation context:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From AggregateCommand
let column = df.column(col_name).map_err(|e| {
    anyhow::anyhow!(
        "Aggregation '{}': column '{}' not found: {}",
        agg.name,
        col_name,
        e
    )
})?;

let count = column.n_unique().map_err(|e| {
    anyhow::anyhow!("Aggregation '{}': n_unique failed: {}", agg.name, e)
})?;
<span class="boring">}</span></code></pre>
<p>Include:</p>
<ul>
<li>The operation being performed (<code>n_unique</code>)</li>
<li>The context (aggregation name)</li>
<li>The underlying error</li>
</ul>
<h2 id="when-to-return-errors-vs-panic"><a class="header" href="#when-to-return-errors-vs-panic">When to Return Errors vs. Panic</a></h2>
<h3 id="return-errors-for"><a class="header" href="#return-errors-for">Return Errors For:</a></h3>
<ul>
<li><strong>User input problems</strong>: Missing files, invalid formats, wrong types</li>
<li><strong>External failures</strong>: Network errors, database errors, API failures</li>
<li><strong>Business logic violations</strong>: Mutually exclusive options, invalid combinations</li>
<li><strong>Runtime state issues</strong>: Missing dependencies, expired tokens</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// User input - return error
if format != "csv" &amp;&amp; format != "json" &amp;&amp; format != "parquet" {
    return Err(anyhow::anyhow!("Unsupported file format: {}", format));
}

// External failure - return error
let response = client.get(&amp;url).send().await
    .map_err(|e| anyhow::anyhow!("HTTP request failed: {}", e))?;
<span class="boring">}</span></code></pre>
<h3 id="panic-for"><a class="header" href="#panic-for">Panic For:</a></h3>
<ul>
<li><strong>Internal invariants</strong>: States that should be impossible if the code is correct</li>
<li><strong>Schema validation</strong>: Caught by <code>CommandSpecBuilder::build()</code> at initialization</li>
<li><strong>Programming errors</strong>: Bugs in your command implementation</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From CommandSpecBuilder::build() - schema validation
let attr = self.attributes.iter()
    .find(|a| &amp;a.name == attribute)
    .unwrap_or_else(|| panic!(
        "Derived result references unknown attribute '{:?}'",
        attribute
    ));

// Internal invariant - something is very wrong
match self.internal_state {
    State::Ready =&gt; { /* proceed */ }
    _ =&gt; unreachable!("execute() called in non-ready state"),
}
<span class="boring">}</span></code></pre>
<p>The rule: <strong>panic for programmer errors, return errors for runtime problems</strong>.</p>
<h2 id="logging-and-errors"><a class="header" href="#logging-and-errors">Logging and Errors</a></h2>
<p>Use <code>tracing</code> to log before returning errors when the error might be hard to diagnose:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Log context that helps debugging
tracing::warn!(
    path = %file_spec.file.display(),
    "File does not exist"
);
return Err(anyhow::anyhow!(
    "File does not exist: {}",
    file_spec.file.display()
));

// Log the query that failed
tracing::warn!(query = %query, "SQL execution error");
return Err(anyhow::anyhow!("SQL execution failed: {}", e));
<span class="boring">}</span></code></pre>
<p>Logging is especially valuable when:</p>
<ul>
<li>The error might be intermittent</li>
<li>Multiple similar operations could fail</li>
<li>The error message alone doesn’t capture all relevant state</li>
</ul>
<h2 id="error-message-guidelines"><a class="header" href="#error-message-guidelines">Error Message Guidelines</a></h2>
<h3 id="do-include"><a class="header" href="#do-include">Do Include:</a></h3>
<ul>
<li>What operation failed</li>
<li>What specific value caused the problem</li>
<li>What was expected vs. what was found</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GOOD
Err(anyhow::anyhow!(
    "Aggregation '{}': column '{}' not found in DataFrame with columns {:?}",
    agg.name,
    col_name,
    df.get_column_names()
))
<span class="boring">}</span></code></pre>
<h3 id="avoid"><a class="header" href="#avoid">Avoid:</a></h3>
<ul>
<li>Generic messages without context</li>
<li>Technical jargon when user-facing</li>
<li>Stack traces in error messages (that’s what <code>RUST_BACKTRACE</code> is for)</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD - no context
Err(anyhow::anyhow!("Column not found"))

// BAD - too technical
Err(anyhow::anyhow!("HashMap::get returned None for TypeId"))

// BAD - error in error message
Err(anyhow::anyhow!("Error: something went wrong"))
<span class="boring">}</span></code></pre>
<h2 id="testing-error-conditions"><a class="header" href="#testing-error-conditions">Testing Error Conditions</a></h2>
<p>Test that your commands fail appropriately:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_missing_file_error() {
    let attrs = Attributes::from_json(json!({
        "files": [{
            "name": "missing",
            "file": "/nonexistent/path.csv",
            "format": "csv"
        }]
    })).unwrap();

    let cmd = FileCommand::from_attributes(&amp;attrs).unwrap();

    let result = cmd.execute(&amp;context, &amp;output_prefix).await;

    assert!(result.is_err());
    let error = result.unwrap_err();
    assert!(error.to_string().contains("does not exist"));
    assert!(error.to_string().contains("/nonexistent/path.csv"));
}
<span class="boring">}</span></code></pre>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<ul>
<li>Use <code>anyhow::Result</code> for all fallible operations</li>
<li>Add context with <code>.context()</code> when processing arrays or nested structures</li>
<li>Convert external errors with <code>map_err</code> and include relevant context</li>
<li>Log with <code>tracing</code> before returning hard-to-diagnose errors</li>
<li>Return errors for runtime problems, panic for programming errors</li>
<li>Include specific values and operation names in error messages</li>
<li>Test error conditions to ensure messages are helpful</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
